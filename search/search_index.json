{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Motion Projectile motion can be analyzed using Newton's laws of motion. Assuming no air resistance, the motion can be decomposed into horizontal and vertical components: Equations of Motion: Horizontal motion: $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion: $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time. Time of Flight: Setting \\( y(t) = 0 \\) to find the total flight time: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range Formula: The horizontal range \\( R \\) is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the range is maximized at \\( \\theta = 45^\\circ \\) , assuming other parameters remain constant. 2. Analysis of the Range Influence of Initial Conditions Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) . Graphical Representation Below is a Python script to visualize how the range changes with \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() 3. Practical Applications Sports : Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin. Engineering : Used in ballistics, military applications, and designing trajectories for rockets and missiles. Astrophysics : Used to model celestial body trajectories and space exploration missions. 4. Implementation A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve. Example: Adding Air Resistance The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions. 5. Limitations and Further Considerations Air resistance : Causes asymmetry and reduces range. Uneven terrain : Requires solving for complex boundary conditions. Wind effects : Affects trajectory unpredictably. Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments. Conclusion Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","text":"Projectile motion can be analyzed using Newton's laws of motion. Assuming no air resistance, the motion can be decomposed into horizontal and vertical components:","title":"Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion: $$ x(t) = v_0 \\cos(\\theta) t $$ Vertical motion: $$ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the acceleration due to gravity, \\(t\\) is the time.","title":"Equations of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\( y(t) = 0 \\) to find the total flight time: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"The horizontal range \\( R \\) is given by: \\[ R = v_0 \\cos(\\theta) t_f = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that the range is maximized at \\( \\theta = 45^\\circ \\) , assuming other parameters remain constant.","title":"Range Formula:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","text":"Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) .","title":"Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","text":"Below is a Python script to visualize how the range changes with \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin. Engineering : Used in ballistics, military applications, and designing trajectories for rockets and missiles. Astrophysics : Used to model celestial body trajectories and space exploration missions.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-air-resistance","text":"The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions.","title":"Example: Adding Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","text":"Air resistance : Causes asymmetry and reduces range. Uneven terrain : Requires solving for complex boundary conditions. Wind effects : Affects trajectory unpredictably. Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments.","title":"5. Limitations and Further Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small Angles For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics. 2. Analysis of Dynamics Influence of System Parameters Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge. Transition to Chaos By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary. 3. Practical Applications The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices : Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges : Helps in understanding oscillations leading to structural failures. - Electrical Circuits : Analogous to driven RLC circuits with damping and external forcing. 4. Implementation Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # damping coefficient g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) # simulation time t_eval = np.linspace(0, 50, 1000) # time steps # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) # Plot results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time. 5. Limitations and Extensions Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Nonlinear damping (e.g., air drag proportional to velocity squared). Non-periodic driving forces to model irregular forcing. Coupled pendulum systems for synchronization studies. 6. Conclusion The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angles","text":"For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters.","title":"Approximate Solutions for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-system-parameters","text":"Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge.","title":"Influence of System Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices : Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges : Helps in understanding oscillations leading to structural failures. - Electrical Circuits : Analogous to driven RLC circuits with damping and external forcing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters b = 0.2 # damping coefficient g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) # simulation time t_eval = np.linspace(0, 50, 1000) # time steps # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) # Plot results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Nonlinear damping (e.g., air drag proportional to velocity squared). Non-periodic driving forces to model irregular forcing. Coupled pendulum systems for synchronization studies.","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation Kepler\u2019s Third Law Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, this can be derived using Newton\u2019s law of gravitation and centripetal force: Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) . Implications in Astronomy Planetary Mass Calculation: Given the period and radius of a planet\u2019s moon, we can determine the planet\u2019s mass. Determining Distances: If the period of a planet\u2019s orbit around the Sun is known, its orbital radius can be estimated. Satellite Orbits: Used to design stable satellite orbits around Earth and other celestial bodies. 2. Real-World Examples The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets. 3. Computational Model The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Computes orbital periods for different radii. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship. 4. Extensions and Limitations Elliptical Orbits: Kepler\u2019s Law applies, but \\( R \\) represents the semi-major axis. Relativistic Effects: General relativity modifies Kepler\u2019s laws in strong gravitational fields. External Forces: Perturbations from other bodies can alter orbits over time. 5. Conclusion Kepler\u2019s Third Law elegantly links orbital period and radius, enabling calculations in celestial mechanics. This relationship remains fundamental in astronomy, satellite engineering, and space exploration.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler\u2019s Third Law states that the square of a planet\u2019s orbital period \\( T \\) is proportional to the cube of its orbital radius \\( R \\) : $$ T^2 \\propto R^3 $$ For a circular orbit, this can be derived using Newton\u2019s law of gravitation and centripetal force: Gravitational Force as Centripetal Force: $$ \\frac{GMm}{R^2} = m \\frac{v^2}{R} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( R \\) is the orbital radius, - \\( v \\) is the orbital velocity. Orbital Velocity from Period: The orbital velocity \\( v \\) is related to the orbital period \\( T \\) as: $$ v = \\frac{2 \\pi R}{T} $$ Deriving Kepler\u2019s Third Law: Substituting \\( v \\) into the force equation and solving for \\( T \\) , we get: $$ T^2 = \\frac{4 \\pi^2}{GM} R^3 $$ This confirms that \\( T^2 \\propto R^3 \\) , where the proportionality constant depends on \\( G \\) and \\( M \\) .","title":"Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Planetary Mass Calculation: Given the period and radius of a planet\u2019s moon, we can determine the planet\u2019s mass. Determining Distances: If the period of a planet\u2019s orbit around the Sun is known, its orbital radius can be estimated. Satellite Orbits: Used to design stable satellite orbits around Earth and other celestial bodies.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"The Moon\u2019s Orbit around Earth The Moon orbits Earth with a period of \\( T = 27.3 \\) days. The average orbital radius is about \\( 3.84 \\times 10^5 \\) km. Using Kepler\u2019s law, we can verify the mass of Earth. Planets in the Solar System Kepler\u2019s law allows us to compare planetary orbits. Example: Earth\u2019s orbital radius \\( 1 \\) AU and period \\( 1 \\) year help determine distances of other planets.","title":"2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-model","text":"The following Python script simulates circular orbits and verifies Kepler\u2019s Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Function to calculate orbital period def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Generate data radii = np.logspace(9, 12, 100) # Orbital radii from 10^9 to 10^12 meters periods = orbital_period(radii) # Verify Kepler's Third Law T_squared = periods**2 R_cubed = radii**3 # Plot T^2 vs R^3 plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, label=\"$T^2 \\propto R^3$\", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Simulating circular orbit def circular_orbit(radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) return x, y # Plot circular orbits for different radii plt.figure(figsize=(8,8)) for r in [1e10, 3e10, 5e10]: x, y = circular_orbit(r) plt.plot(x, y, label=f\"Radius = {r:.0e} m\") plt.scatter(0, 0, color='orange', label='Central Mass (e.g., Sun)') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbits\") plt.legend() plt.grid() plt.axis(\"equal\") plt.show() This script: - Computes orbital periods for different radii. - Plots \\( T^2 \\) vs. \\( R^3 \\) to confirm a linear relationship.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extensions-and-limitations","text":"Elliptical Orbits: Kepler\u2019s Law applies, but \\( R \\) represents the semi-major axis. Relativistic Effects: General relativity modifies Kepler\u2019s laws in strong gravitational fields. External Forces: Perturbations from other bodies can alter orbits over time.","title":"4. Extensions and Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler\u2019s Third Law elegantly links orbital period and radius, enabling calculations in celestial mechanics. This relationship remains fundamental in astronomy, satellite engineering, and space exploration.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Theoretical Foundation Definition of Cosmic Velocities Cosmic velocities define the minimum speeds required to achieve different types of motion in space: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun. 2. Mathematical Analysis Factors Affecting Velocities: Mass ( \\( M \\) ) : More massive bodies require higher velocities. Radius ( \\( R \\) ) : Smaller bodies require higher velocities due to stronger surface gravity. Relation between Velocities: Escape velocity is always greater than orbital velocity. Achieving interstellar travel requires exceeding the third cosmic velocity. 3. Computational Model Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def cosmic_velocities(mass, radius): \"\"\"Calculate first, second, and third cosmic velocities.\"\"\" v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Celestial bodies data (mass in kg, radius in m) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(mass, radius) for body, (mass, radius) in bodies.items()} # Visualization labels, v1_vals, v2_vals = zip(*[(body, v[0], v[1]) for body, v in velocities.items()]) x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width/2, v1_vals, width, label='First Cosmic Velocity (km/s)', color='b') ax.bar(x + width/2, v2_vals, width, label='Second Cosmic Velocity (km/s)', color='r') ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel('Velocity (m/s)') ax.set_title('First and Second Cosmic Velocities') ax.legend() plt.grid() plt.show() This script: - Calculates orbital and escape velocities for different celestial bodies. - Plots a comparison of these velocities. 4. Importance in Space Exploration Satellite Launches: First cosmic velocity is critical for stable satellite orbits. Interplanetary Missions: Escape velocity is needed for missions to Mars and beyond. Interstellar Travel: The third cosmic velocity is required for leaving the Solar System, as achieved by Voyager 1. 5. Conclusion Understanding escape and cosmic velocities is essential for space exploration. These velocities dictate satellite deployment, planetary missions, and interstellar travel feasibility.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definition-of-cosmic-velocities","text":"Cosmic velocities define the minimum speeds required to achieve different types of motion in space: First Cosmic Velocity (Orbital Velocity) The minimum velocity needed to achieve a stable circular orbit around a celestial body. Derived from the balance between gravitational force and centripetal force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The velocity required to break free from a celestial body's gravitational influence without further propulsion. Derived from the energy conservation principle: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Notably, \\( v_2 = \\sqrt{2} v_1 \\) . Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational field from a planet\u2019s orbit. Computed by combining the escape velocity from a planet and the velocity required to escape the Sun\u2019s gravity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\( v_{sun} \\) is the orbital velocity of the planet around the Sun.","title":"Definition of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-analysis","text":"Factors Affecting Velocities: Mass ( \\( M \\) ) : More massive bodies require higher velocities. Radius ( \\( R \\) ) : Smaller bodies require higher velocities due to stronger surface gravity. Relation between Velocities: Escape velocity is always greater than orbital velocity. Achieving interstellar travel requires exceeding the third cosmic velocity.","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-computational-model","text":"Below is a Python script to calculate and visualize cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G def cosmic_velocities(mass, radius): \"\"\"Calculate first, second, and third cosmic velocities.\"\"\" v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 # Celestial bodies data (mass in kg, radius in m) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } velocities = {body: cosmic_velocities(mass, radius) for body, (mass, radius) in bodies.items()} # Visualization labels, v1_vals, v2_vals = zip(*[(body, v[0], v[1]) for body, v in velocities.items()]) x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width/2, v1_vals, width, label='First Cosmic Velocity (km/s)', color='b') ax.bar(x + width/2, v2_vals, width, label='Second Cosmic Velocity (km/s)', color='r') ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel('Velocity (m/s)') ax.set_title('First and Second Cosmic Velocities') ax.legend() plt.grid() plt.show() This script: - Calculates orbital and escape velocities for different celestial bodies. - Plots a comparison of these velocities.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-importance-in-space-exploration","text":"Satellite Launches: First cosmic velocity is critical for stable satellite orbits. Interplanetary Missions: Escape velocity is needed for missions to Mars and beyond. Interstellar Travel: The third cosmic velocity is required for leaving the Solar System, as achieved by Voyager 1.","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-conclusion","text":"Understanding escape and cosmic velocities is essential for space exploration. These velocities dictate satellite deployment, planetary missions, and interstellar travel feasibility.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Theoretical Foundation Types of Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory) : If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory) : If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory) : If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion. 2. Mathematical Analysis Equations of Motion The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations. 3. Computational Model The following Python script simulates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in km, velocity in km/s) x0, y0 = R + 500000, 0 # Initial altitude: 500 km vx0, vy0 = 7.8e3, 0 # Initial velocity (near orbital velocity) y_init = [x0, vx0, y0, vy0] # Time span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve ODE sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of a Freely Released Payload') plt.legend() plt.grid() plt.show() This script: - Defines gravitational equations of motion. - Uses numerical integration to compute the trajectory. - Plots the resulting trajectory. 4. Practical Applications Satellite Deployment : Ensuring correct initial conditions for stable orbits. Reentry Scenarios : Calculating reentry angles and speeds. Escape Missions : Planning interplanetary transfers. 5. Conclusion Understanding the possible trajectories of a released payload is crucial for space missions. By analyzing the velocity and gravitational influence, we can determine whether an object will reenter, orbit, or escape Earth.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory) : If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory) : If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory) : If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computational-model","text":"The following Python script simulates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in km, velocity in km/s) x0, y0 = R + 500000, 0 # Initial altitude: 500 km vx0, vy0 = 7.8e3, 0 # Initial velocity (near orbital velocity) y_init = [x0, vx0, y0, vy0] # Time span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve ODE sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of a Freely Released Payload') plt.legend() plt.grid() plt.show() This script: - Defines gravitational equations of motion. - Uses numerical integration to compute the trajectory. - Plots the resulting trajectory.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-practical-applications","text":"Satellite Deployment : Ensuring correct initial conditions for stable orbits. Reentry Scenarios : Calculating reentry angles and speeds. Escape Missions : Planning interplanetary transfers.","title":"4. Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"Understanding the possible trajectories of a released payload is crucial for space missions. By analyzing the velocity and gravitational influence, we can determine whether an object will reenter, orbit, or escape Earth.","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Theoretical Background Wave Interference Interference occurs when two or more waves overlap, leading to constructive (amplification) and destructive (cancellation) effects. On a water surface, waves emanating from multiple sources interact to form intricate interference patterns. The displacement \\( \\eta(x, y, t) \\) of a circular wave originating from a point source \\( (x_0, y_0) \\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: - \\( A \\) is the wave amplitude, - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the radial distance from the source, - \\( \\phi \\) is the initial phase. When multiple sources are present, the net displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of sources. 2. Problem Setup 1. Choosing a Regular Polygon We select a regular polygon (e.g., equilateral triangle, square, pentagon) and place wave sources at its vertices. 2. Computing the Superposition Each vertex of the polygon acts as a wave source, and their combined effect determines the final interference pattern. 3. Computational Model The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_ = 10 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (arbitrary unit) t = 0 # Time snapshot # Define polygon vertices (square as an example) N = 4 # Number of sources (square) radius = 20 # Distance from center angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Define grid for visualization x = np.linspace(-30, 30, 300) y = np.linspace(-30, 30, 300) X, Y = np.meshgrid(x, y) # Compute wave interference pattern eta_sum = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t) # Avoid division by zero # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.imshow(eta_sum, extent=[-30, 30, -30, 30], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Interference Pattern for a Square Wave Source') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show() 4. Observations and Analysis Constructive Interference : Bright regions indicate where wave crests reinforce each other. Destructive Interference : Dark regions indicate cancellation due to phase differences. Polygonal Symmetry : The interference pattern reflects the symmetry of the chosen polygon. 5. Conclusion This simulation demonstrates how waves from multiple sources interact to form interference patterns. By varying the polygon shape and wave parameters, we can analyze different wave behaviors useful in acoustics, optics, and fluid dynamics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a Water Surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference","text":"Interference occurs when two or more waves overlap, leading to constructive (amplification) and destructive (cancellation) effects. On a water surface, waves emanating from multiple sources interact to form intricate interference patterns. The displacement \\( \\eta(x, y, t) \\) of a circular wave originating from a point source \\( (x_0, y_0) \\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: - \\( A \\) is the wave amplitude, - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the radial distance from the source, - \\( \\phi \\) is the initial phase. When multiple sources are present, the net displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of sources.","title":"Wave Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-problem-setup","text":"","title":"2. Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-choosing-a-regular-polygon","text":"We select a regular polygon (e.g., equilateral triangle, square, pentagon) and place wave sources at its vertices.","title":"1. Choosing a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-computing-the-superposition","text":"Each vertex of the polygon acts as a wave source, and their combined effect determines the final interference pattern.","title":"2. Computing the Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-model","text":"The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_ = 10 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (arbitrary unit) t = 0 # Time snapshot # Define polygon vertices (square as an example) N = 4 # Number of sources (square) radius = 20 # Distance from center angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Define grid for visualization x = np.linspace(-30, 30, 300) y = np.linspace(-30, 30, 300) X, Y = np.meshgrid(x, y) # Compute wave interference pattern eta_sum = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t) # Avoid division by zero # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.imshow(eta_sum, extent=[-30, 30, -30, 30], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Interference Pattern for a Square Wave Source') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show()","title":"3. Computational Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"Constructive Interference : Bright regions indicate where wave crests reinforce each other. Destructive Interference : Dark regions indicate cancellation due to phase differences. Polygonal Symmetry : The interference pattern reflects the symmetry of the chosen polygon.","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This simulation demonstrates how waves from multiple sources interact to form interference patterns. By varying the polygon shape and wave parameters, we can analyze different wave behaviors useful in acoustics, optics, and fluid dynamics.","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Charged Particle Motion in Electric and Magnetic Fields 1. Theoretical Background The Lorentz Force The motion of a charged particle in electric and magnetic fields is governed by the Lorentz force equation: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] where: - \\( q \\) is the charge of the particle, - \\( \\mathbf{E} \\) is the electric field, - \\( \\mathbf{B} \\) is the magnetic field, - \\( \\mathbf{v} \\) is the velocity of the particle. The trajectory of a charged particle depends on the initial conditions and the configuration of the fields. In a uniform magnetic field, the motion is typically circular or helical due to the perpendicular force exerted by \\( \\mathbf{B} \\) on \\( \\mathbf{v} \\) . 2. Problem Setup 1. Choosing Field Configurations We consider three cases: 1. A uniform magnetic field \\( \\mathbf{B} \\) alone. 2. Combined uniform electric and magnetic fields. 3. Crossed electric and magnetic fields. 2. Computing the Motion Using numerical integration, we compute the particle's trajectory under the influence of the Lorentz force. 3. Computational Model The following Python script simulates and visualizes the motion of a charged particle in an electromagnetic field. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants (modifiable for parameter exploration) q = 1.6e-19 # Charge of the particle (C) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Uniform magnetic field (T) E = np.array([0, 0, 0]) # Electric field (V/m) v0 = np.array([1e6, 0, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) dt = 1e-10 # Time step (s) n_steps = 1000 # Number of time steps def lorentz_force(q, v, E, B): \"\"\"Computes the Lorentz force.\"\"\" return q * (E + np.cross(v, B)) def simulate_motion(q, m, E, B, v0, r0, dt, n_steps): \"\"\"Simulates the motion of a charged particle in E and B fields.\"\"\" r = np.zeros((n_steps, 3)) v = np.zeros((n_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, n_steps): F = lorentz_force(q, v[i-1], E, B) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run simulation r, v = simulate_motion(q, m, E, B, v0, r0, dt, n_steps) # Visualization fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Motion in a Magnetic Field') ax.legend() plt.show() 4. Observations and Analysis Circular Motion : In a uniform magnetic field, the particle follows a circular or helical path depending on the initial velocity. Effect of Electric Field : Introducing an electric field results in drift motion. Larmor Radius : The radius of the circular trajectory is determined by the balance of magnetic force and centripetal acceleration. 5. Conclusion This simulation provides insights into charged particle dynamics in electromagnetic fields, relevant to applications such as cyclotrons, plasma confinement, and astrophysics. Extending this model to non-uniform fields or relativistic velocities can offer deeper insights into complex systems.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"Charged Particle Motion in Electric and Magnetic Fields","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#the-lorentz-force","text":"The motion of a charged particle in electric and magnetic fields is governed by the Lorentz force equation: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] where: - \\( q \\) is the charge of the particle, - \\( \\mathbf{E} \\) is the electric field, - \\( \\mathbf{B} \\) is the magnetic field, - \\( \\mathbf{v} \\) is the velocity of the particle. The trajectory of a charged particle depends on the initial conditions and the configuration of the fields. In a uniform magnetic field, the motion is typically circular or helical due to the perpendicular force exerted by \\( \\mathbf{B} \\) on \\( \\mathbf{v} \\) .","title":"The Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-problem-setup","text":"","title":"2. Problem Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-choosing-field-configurations","text":"We consider three cases: 1. A uniform magnetic field \\( \\mathbf{B} \\) alone. 2. Combined uniform electric and magnetic fields. 3. Crossed electric and magnetic fields.","title":"1. Choosing Field Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-computing-the-motion","text":"Using numerical integration, we compute the particle's trajectory under the influence of the Lorentz force.","title":"2. Computing the Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-computational-model","text":"The following Python script simulates and visualizes the motion of a charged particle in an electromagnetic field. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants (modifiable for parameter exploration) q = 1.6e-19 # Charge of the particle (C) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Uniform magnetic field (T) E = np.array([0, 0, 0]) # Electric field (V/m) v0 = np.array([1e6, 0, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) dt = 1e-10 # Time step (s) n_steps = 1000 # Number of time steps def lorentz_force(q, v, E, B): \"\"\"Computes the Lorentz force.\"\"\" return q * (E + np.cross(v, B)) def simulate_motion(q, m, E, B, v0, r0, dt, n_steps): \"\"\"Simulates the motion of a charged particle in E and B fields.\"\"\" r = np.zeros((n_steps, 3)) v = np.zeros((n_steps, 3)) r[0] = r0 v[0] = v0 for i in range(1, n_steps): F = lorentz_force(q, v[i-1], E, B) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Run simulation r, v = simulate_motion(q, m, E, B, v0, r0, dt, n_steps) # Visualization fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Motion in a Magnetic Field') ax.legend() plt.show()","title":"3. Computational Model"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-observations-and-analysis","text":"Circular Motion : In a uniform magnetic field, the particle follows a circular or helical path depending on the initial velocity. Effect of Electric Field : Introducing an electric field results in drift motion. Larmor Radius : The radius of the circular trajectory is determined by the balance of magnetic force and centripetal acceleration.","title":"4. Observations and Analysis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-conclusion","text":"This simulation provides insights into charged particle dynamics in electromagnetic fields, relevant to applications such as cyclotrons, plasma confinement, and astrophysics. Extending this model to non-uniform fields or relativistic velocities can offer deeper insights into complex systems.","title":"5. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}