{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#technical-setup","title":"Technical setup","text":"<ul> <li>Install Visual Studio Code from here</li> <li>Install folowing extensions in Visual Studio Code:<ul> <li>Github Repositories (GitHub, Inc.)</li> <li>GitHub Copilot (GitHub Copilot)</li> <li>GitHub Actions (GitHub, Inc.)</li> <li>Python (Microsoft)</li> </ul> </li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Python</li> <li>Miniconda Documentation</li> <li>Google Colab</li> </ul>"},{"location":"#how-to-use-this-repository","title":"How to use this repository","text":"<p>Below are the steps you need to follow:</p> <ol> <li>Create a GitHub account if you don\u2019t have one.</li> <li>Fork this repository to your account. </li> <li>Enable the Issues tab:<ul> <li>Go to the <code>Settings</code> tab and check the Issues option. </li> </ul> </li> <li>Add your professor as a collaborator:<ul> <li>Go to the <code>Settings</code> tab and add their GitHub username in the Collaborators section. </li> </ul> </li> <li>Install python: Download</li> </ol> <p>Source Code &amp; WWW</p> <ul> <li>GitHub repo</li> <li>WWW</li> </ul>"},{"location":"#where-can-i-find-the-problems","title":"Where can I find the problems?","text":"<p>Please visit the Mathematics Physics Lectures website.</p> <ul> <li>Physics</li> <li>Mathematics</li> <li>Discret Mathematics</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","title":"Problem 1","text":"<p>Investigating the Range as a Function of the Angle of Projection</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","title":"Governing Equations of Motion","text":"<p>Projectile motion can be analyzed using Newton's laws of motion. For a more complete analysis, let's start with the fundamental differential equations:</p> \\[ \\frac{d^2x}{dt^2} = 0 $$ $$ \\frac{d^2y}{dt^2} = -g \\] <p>Integrating these equations with initial conditions: $$ v_{0x} = v_0\\cos(\\theta) $$ $$ v_{0y} = v_0\\sin(\\theta) $$</p> <p>We get the velocity components: $$ v_x(t) = v_0\\cos(\\theta) $$ $$ v_y(t) = v_0\\sin(\\theta) - gt $$</p> <p>And the position components: $$ x(t) = v_0\\cos(\\theta)t $$ $$ y(t) = v_0\\sin(\\theta)t - \\frac{1}{2}gt^2 $$</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhanced-analysis-of-flight-characteristics","title":"Enhanced Analysis of Flight Characteristics","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","title":"Maximum Height:","text":"<p>The maximum height occurs when \\(v_y(t) = 0\\): $$ h_{max} = \\frac{v_0^2\\sin^2(\\theta)}{2g} $$</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","title":"Time of Flight:","text":"\\[ t_f = \\frac{2v_0\\sin(\\theta)}{g} \\]"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","title":"Range Formula:","text":"\\[ R = \\frac{v_0^2\\sin(2\\theta)}{g} \\] <p>Let's create a more comprehensive visualization that shows both the trajectory and range analysis:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\ndef trajectory(t, v0, theta, g=9.81):\n    x = v0 * np.cos(np.radians(theta)) * t\n    y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2\n    return x, y\n\ndef range_function(theta, v0, g=9.81):\n    return (v0**2 * np.sin(2 * np.radians(theta))) / g\n\n# Parameters\nv0 = 20  # initial velocity in m/s\ng = 9.81  # gravity\n\n# Create figure with GridSpec\nfig = plt.figure(figsize=(15, 10))\ngs = GridSpec(2, 2, figure=fig)\n\n# Plot 1: Range vs Angle\nax1 = fig.add_subplot(gs[0, 0])\ntheta = np.linspace(0, 90, 100)\nranges = range_function(theta, v0, g)\nax1.plot(theta, ranges, 'b-', label=f'v0 = {v0} m/s')\nax1.set_xlabel('Launch Angle (degrees)')\nax1.set_ylabel('Range (m)')\nax1.set_title('Range vs Launch Angle')\nax1.grid(True)\nax1.legend()\n\n# Plot 2: Multiple Trajectories\nax2 = fig.add_subplot(gs[0, 1])\nangles = [15, 30, 45, 60, 75]\nt = np.linspace(0, 3, 100)\nfor angle in angles:\n    x, y = trajectory(t, v0, angle)\n    ax2.plot(x, y, label=f'\u03b8 = {angle}\u00b0')\nax2.set_xlabel('Distance (m)')\nax2.set_ylabel('Height (m)')\nax2.set_title('Projectile Trajectories')\nax2.grid(True)\nax2.legend()\n\n# Plot 3: Range vs Initial Velocity\nax3 = fig.add_subplot(gs[1, 0])\nv0_range = np.linspace(0, 30, 100)\ntheta_fixed = 45  # optimal angle\nranges_v0 = range_function(theta_fixed, v0_range)\nax3.plot(v0_range, ranges_v0, 'r-')\nax3.set_xlabel('Initial Velocity (m/s)')\nax3.set_ylabel('Range (m)')\nax3.set_title('Range vs Initial Velocity (\u03b8 = 45\u00b0)')\nax3.grid(True)\n\n# Plot 4: Maximum Height vs Angle\nax4 = fig.add_subplot(gs[1, 1])\nh_max = (v0**2 * np.sin(np.radians(theta))**2) / (2*g)\nax4.plot(theta, h_max, 'g-')\nax4.set_xlabel('Launch Angle (degrees)')\nax4.set_ylabel('Maximum Height (m)')\nax4.set_title('Maximum Height vs Launch Angle')\nax4.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#advanced-analysis-with-air-resistance","title":"Advanced Analysis with Air Resistance","text":"<p>When considering air resistance, the equations become:</p> \\[ m\\frac{d^2x}{dt^2} = -kv_x|v| $$ $$ m\\frac{d^2y}{dt^2} = -mg - kv_y|v| \\] <p>where \\(k\\) is the drag coefficient and \\(|v|\\) is the magnitude of velocity.</p> <p>Let's simulate this using numerical integration:</p> <pre><code>from scipy.integrate import odeint\n\ndef projectile_with_drag(state, t, k, m, g):\n    x, y, vx, vy = state\n    v = np.sqrt(vx**2 + vy**2)\n\n    dxdt = vx\n    dydt = vy\n    dvxdt = -k/m * vx * v\n    dvydt = -g - k/m * vy * v\n\n    return [dxdt, dydt, dvxdt, dvydt]\n\n# Parameters\nm = 1.0  # mass in kg\nk = 0.1  # drag coefficient\nt = np.linspace(0, 2, 1000)\ntheta = 45  # degrees\n\n# Initial conditions\nv0 = 20\nstate0 = [0, 0, v0*np.cos(np.radians(theta)), v0*np.sin(np.radians(theta))]\n\n# Solve ODE\nsolution = odeint(projectile_with_drag, state0, t, args=(k, m, g))\n\nplt.figure(figsize=(10, 6))\nplt.plot(solution[:, 0], solution[:, 1], 'b-', label='With drag')\nx_no_drag, y_no_drag = trajectory(t, v0, theta)\nplt.plot(x_no_drag, y_no_drag, 'r--', label='Without drag')\nplt.xlabel('Distance (m)')\nplt.ylabel('Height (m)')\nplt.title('Comparison of Trajectories With and Without Air Resistance')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","title":"2. Analysis of the Range","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","title":"Influence of Initial Conditions","text":"<ul> <li>Initial velocity (\\( v_0 \\)): Increasing \\( v_0 \\) increases the range quadratically.</li> <li>Gravitational acceleration (\\( g \\)): Higher \\( g \\) reduces the range, as the projectile falls more quickly.</li> <li>Launch angle (\\( \\theta \\)): The range follows a symmetric pattern, peaking at \\( 45^\\circ \\).</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","title":"Graphical Representation","text":"<p>Below is a Python script to visualize how the range changes with \\( \\theta \\):</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndef range_function(theta, v0, g=9.81):\n    return (v0**2 * np.sin(2 * np.radians(theta))) / g\n\n# Parameters\nv0 = 20  # initial velocity in m/s\ntheta = np.linspace(0, 90, 100)  # range of angles\ng = 9.81  # gravity\n\n# Compute ranges\nranges = range_function(theta, v0, g)\n\n# Plot results\nplt.figure(figsize=(8,5))\nplt.plot(theta, ranges, label=f'v0 = {v0} m/s')\nplt.xlabel('Launch Angle (degrees)')\nplt.ylabel('Range (m)')\nplt.title('Projectile Range vs. Launch Angle')\nplt.legend()\nplt.grid()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","title":"3. Practical Applications","text":"<ul> <li>Sports: Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin.</li> <li>Engineering: Used in ballistics, military applications, and designing trajectories for rockets and missiles.</li> <li>Astrophysics: Used to model celestial body trajectories and space exploration missions.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","title":"4. Implementation","text":"<p>A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-air-resistance","title":"Example: Adding Air Resistance","text":"<p>The equations with drag \\(F_d = -k v^2\\) lead to:</p> \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] <p>A numerical solver like Python's SciPy can be used to compute solutions.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","title":"5. Limitations and Further Considerations","text":"<ul> <li>Air resistance: Causes asymmetry and reduces range.</li> <li>Uneven terrain: Requires solving for complex boundary conditions.</li> <li>Wind effects: Affects trajectory unpredictably.</li> </ul> <p>Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","title":"Conclusion","text":"<p>Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","title":"Problem 2","text":"<p>Investigating the Dynamics of a Forced Damped Pendulum</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","title":"Governing Equation","text":"<p>The motion of a forced damped pendulum is governed by the nonlinear differential equation:</p> \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] <p>where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angles","title":"Approximate Solutions for Small Angles","text":"<p>For small angles (\\( \\theta \\approx \\sin \\theta \\)), the equation simplifies to:</p> \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] <p>This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form:</p> \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] <p>where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\), and system parameters.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","title":"Resonance Conditions","text":"<p>Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\), leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","title":"2. Analysis of Dynamics","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-system-parameters","title":"Influence of System Parameters","text":"<ul> <li>Damping Coefficient (\\( b \\)): Higher damping suppresses oscillations and prevents chaotic motion.</li> <li>Driving Amplitude (\\( A \\)): Larger amplitudes can induce chaotic behavior and bifurcations.</li> <li>Driving Frequency (\\( \\omega \\)): At specific values, resonance or chaos can emerge.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","title":"Transition to Chaos","text":"<p>By varying \\( A \\) and \\( \\omega \\), the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using:</p> <ul> <li>Phase Diagrams: Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability.</li> <li>Poincar\u00e9 Sections: Discrete-time slices revealing periodicity or chaos.</li> <li>Bifurcation Diagrams: Showing system behavior changes as parameters vary.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","title":"3. Practical Applications","text":"<p>The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices: Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges: Helps in understanding oscillations leading to structural failures. - Electrical Circuits: Analogous to driven RLC circuits with damping and external forcing.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","title":"4. Implementation","text":"<p>Below is a Python script to simulate and visualize the forced damped pendulum.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef forced_damped_pendulum(t, y, b, g, L, A, omega):\n    theta, omega_dot = y\n    dtheta_dt = omega_dot\n    domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t)\n    return [dtheta_dt, domega_dt]\n\n# Enhanced parameter set\nb_values = [0.1, 0.5, 1.0]  # different damping coefficients\ng = 9.81  # gravity (m/s^2)\nL = 1.0   # pendulum length (m)\nA = 1.2   # driving force amplitude\nomega = 2.0  # driving frequency\ny0 = [0.1, 0]  # initial conditions: [theta(0), omega(0)]\nt_span = (0, 50)\nt_eval = np.linspace(0, 50, 1000)\n\n# Create subplots for different analyses\nplt.figure(figsize=(15, 10))\n\n# Plot 1: Compare different damping coefficients\nplt.subplot(2, 2, 1)\nfor b in b_values:\n    sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                    args=(b, g, L, A, omega))\n    plt.plot(sol.t, sol.y[0], label=f'b = {b}')\nplt.xlabel('Time (s)')\nplt.ylabel('Angle (rad)')\nplt.title('Effect of Damping Coefficient')\nplt.legend()\nplt.grid(True)\n\n# Plot 2: Phase Space Portrait\nplt.subplot(2, 2, 2)\nb = 0.2  # Use moderate damping for phase space\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\nplt.plot(sol.y[0], sol.y[1])\nplt.xlabel('\u03b8 (rad)')\nplt.ylabel('d\u03b8/dt (rad/s)')\nplt.title('Phase Space Portrait')\nplt.grid(True)\n\n# Plot 3: Resonance Analysis\nfrequencies = np.linspace(0.5, 4, 50)\namplitudes = []\nb = 0.2\nfor w in frequencies:\n    sol = solve_ivp(forced_damped_pendulum, (0, 100), y0, t_eval=np.linspace(80, 100, 200), \n                    args=(b, g, L, A, w))\n    amplitudes.append(np.max(np.abs(sol.y[0])))\n\nplt.subplot(2, 2, 3)\nplt.plot(frequencies, amplitudes)\nplt.xlabel('Driving Frequency \u03c9 (rad/s)')\nplt.ylabel('Maximum Amplitude (rad)')\nplt.title('Resonance Curve')\nplt.grid(True)\n\n# Plot 4: Energy Analysis\ndef system_energy(theta, omega, L, g):\n    kinetic = 0.5 * L**2 * omega**2\n    potential = g * L * (1 - np.cos(theta))\n    return kinetic + potential\n\nb = 0.2\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\nenergies = [system_energy(theta, omega, L, g) \n           for theta, omega in zip(sol.y[0], sol.y[1])]\n\nplt.subplot(2, 2, 4)\nplt.plot(sol.t, energies)\nplt.xlabel('Time (s)')\nplt.ylabel('Total Energy (J)')\nplt.title('System Energy Evolution')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# 3D Phase Space Trajectory\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(111, projection='3d')\n\nb = 0.2\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\n\nax.plot(sol.y[0], sol.y[1], sol.t)\nax.set_xlabel('\u03b8 (rad)')\nax.set_ylabel('d\u03b8/dt (rad/s)')\nax.set_zlabel('Time (s)')\nax.set_title('3D Phase Space Trajectory')\nplt.show()\n\n# Poincar\u00e9 Section\nplt.figure(figsize=(8, 8))\nt_long = np.linspace(0, 200, 4000)\nsol = solve_ivp(forced_damped_pendulum, (0, 200), y0, t_eval=t_long, \n                args=(b, g, L, A, omega))\n\n# Sample points at driving period\nperiod = 2*np.pi/omega\nindices = [i for i in range(len(t_long)) \n          if abs((t_long[i] % period)) &lt; 0.1]\n\nplt.scatter(sol.y[0][indices], sol.y[1][indices], s=1)\nplt.xlabel('\u03b8 (rad)')\nplt.ylabel('d\u03b8/dt (rad/s)')\nplt.title('Poincar\u00e9 Section')\nplt.grid(True)\nplt.show()\n</code></pre> <p>This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time.</p> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","title":"5. Limitations and Extensions","text":"<ul> <li>Limitations: Assumes a point mass pendulum, ignores friction and air resistance.</li> <li>Extensions: </li> <li>Nonlinear damping (e.g., air drag proportional to velocity squared).</li> <li>Non-periodic driving forces to model irregular forcing.</li> <li>Coupled pendulum systems for synchronization studies.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","title":"6. Conclusion","text":"<p>The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/","title":"Problem 1","text":"<p>Orbital Period and Orbital Radius</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-basic-principles","title":"1.1 Basic Principles","text":"<p>The relationship between orbital period and radius emerges from two fundamental principles: 1. Newton's Law of Universal Gravitation 2. Centripetal Force</p> <p>For a body in circular orbit:</p> \\[ F_g = F_c \\] \\[ \\frac{GMm}{r^2} = m\\frac{v^2}{r} \\] <p>where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-derivation-of-keplers-third-law","title":"1.2 Derivation of Kepler's Third Law","text":"<p>For circular orbits, the velocity can be expressed as:</p> \\[ v = \\frac{2\\pi r}{T} \\] <p>Substituting this into the force equation:</p> \\[ \\frac{GMm}{r^2} = m\\frac{4\\pi^2r^2}{T^2r} \\] <p>Simplifying:</p> \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] <p>This is Kepler's Third Law in its exact form, showing that:</p> \\[ T^2 \\propto r^3 \\]"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-computational-analysis","title":"2. Computational Analysis","text":"<p>Let's create a comprehensive visualization suite to analyze orbital dynamics:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib.gridspec import GridSpec\n\n# Constants\nG = 6.67430e-11  # Gravitational constant\nM_earth = 5.972e24  # Earth mass in kg\nM_sun = 1.989e30  # Sun mass in kg\n\ndef orbital_period(radius, central_mass):\n    return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass))\n\ndef plot_orbit_3d(ax, radius, num_points=100):\n    theta = np.linspace(0, 2*np.pi, num_points)\n    x = radius * np.cos(theta)\n    y = radius * np.sin(theta)\n    z = np.zeros_like(theta)\n    ax.plot(x, y, z)\n\n# Create figure with multiple subplots\nfig = plt.figure(figsize=(15, 12))\ngs = GridSpec(2, 2, figure=fig)\n\n# Plot 1: T\u00b2 vs r\u00b3 relationship\nax1 = fig.add_subplot(gs[0, 0])\nradii = np.linspace(1e8, 1e9, 100)\nperiods = orbital_period(radii, M_earth)\nT_squared = periods**2\nr_cubed = radii**3\n\nax1.plot(r_cubed, T_squared, 'b-', label='Earth Satellites')\nax1.set_xlabel('Orbital Radius Cubed (m\u00b3)')\nax1.set_ylabel('Period Squared (s\u00b2)')\nax1.set_title(\"Kepler's Third Law Verification\")\nax1.grid(True)\nax1.legend()\n\n# Plot 2: 3D Orbital Visualization\nax2 = fig.add_subplot(gs[0, 1], projection='3d')\nradii_3d = [4e8, 6e8, 8e8]\ncolors = ['b', 'g', 'r']\n\nfor r, c in zip(radii_3d, colors):\n    plot_orbit_3d(ax2, r)\nax2.scatter([0], [0], [0], color='yellow', s=100, label='Earth')\nax2.set_xlabel('X (m)')\nax2.set_ylabel('Y (m)')\nax2.set_zlabel('Z (m)')\nax2.set_title('3D Visualization of Circular Orbits')\n\n# Plot 3: Orbital Velocity vs Radius\nax3 = fig.add_subplot(gs[1, 0])\nradii_v = np.linspace(1e7, 1e9, 100)\nvelocities = np.sqrt(G * M_earth / radii_v)\n\nax3.plot(radii_v, velocities, 'r-')\nax3.set_xlabel('Orbital Radius (m)')\nax3.set_ylabel('Orbital Velocity (m/s)')\nax3.set_title('Orbital Velocity vs Radius')\nax3.grid(True)\n\n# Plot 4: Energy Analysis\nax4 = fig.add_subplot(gs[1, 1])\nkinetic_energy = 0.5 * velocities**2\npotential_energy = -G * M_earth / radii_v\ntotal_energy = kinetic_energy + potential_energy\n\nax4.plot(radii_v, kinetic_energy, 'b-', label='Kinetic Energy')\nax4.plot(radii_v, potential_energy, 'r-', label='Potential Energy')\nax4.plot(radii_v, total_energy, 'g-', label='Total Energy')\nax4.set_xlabel('Orbital Radius (m)')\nax4.set_ylabel('Energy per unit mass (J/kg)')\nax4.set_title('Orbital Energy Analysis')\nax4.grid(True)\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications","title":"3. Real-World Applications","text":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-satellite-orbits","title":"3.1 Satellite Orbits","text":"<p>Let's analyze different types of satellite orbits:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Constants for common satellite orbits\nLEO_height = 400e3  # Low Earth Orbit\nGEO_height = 35786e3  # Geostationary Orbit\nR_earth = 6371e3  # Earth radius\n\ndef plot_satellite_orbits():\n    fig, ax = plt.subplots(figsize=(10, 10))\n\n    # Plot Earth\n    earth_circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth')\n    ax.add_artist(earth_circle)\n\n    # Plot orbits\n    theta = np.linspace(0, 2*np.pi, 100)\n\n    # LEO\n    leo_radius = R_earth + LEO_height\n    ax.plot(leo_radius*np.cos(theta), leo_radius*np.sin(theta), 'r-', label='LEO')\n\n    # GEO\n    geo_radius = R_earth + GEO_height\n    ax.plot(geo_radius*np.cos(theta), geo_radius*np.sin(theta), 'g-', label='GEO')\n\n    ax.set_aspect('equal')\n    ax.grid(True)\n    ax.set_xlabel('Distance (m)')\n    ax.set_ylabel('Distance (m)')\n    ax.set_title('Common Satellite Orbits')\n    ax.legend()\n\n    # Set limits to show both orbits clearly\n    limit = GEO_height + R_earth\n    ax.set_xlim(-limit, limit)\n    ax.set_ylim(-limit, limit)\n\n    plt.show()\n\nplot_satellite_orbits()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-solar-system-analysis","title":"3.2 Solar System Analysis","text":"<p>The relationship extends to planetary orbits:</p> Planet Orbital Period (years) Semi-major Axis (AU) T\u00b2/r\u00b3 (constant) Mercury 0.24 0.39 1.00 Venus 0.62 0.72 1.00 Earth 1.00 1.00 1.00 Mars 1.88 1.52 1.00"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-limitations-and-extensions","title":"4. Limitations and Extensions","text":"<ol> <li>Elliptical Orbits: For non-circular orbits, r becomes the semi-major axis.</li> <li>Relativistic Effects: At high velocities or strong gravitational fields, corrections are needed.</li> <li>Multi-body Systems: Additional terms required for n-body problems.</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","title":"5. Conclusion","text":"<p>Kepler's Third Law provides a powerful tool for understanding orbital dynamics, from artificial satellites to planetary motion. The computational models demonstrate the precise mathematical relationships governing orbital motion and provide insights into the design of space missions and the study of celestial mechanics.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","title":"References","text":"<ol> <li>Classical Mechanics (Goldstein)</li> <li>Orbital Mechanics for Engineering Students (Curtis)</li> <li>Fundamentals of Astrodynamics (Bate, Mueller, White) </li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_2/","title":"Problem 2","text":"<p>Escape Velocities and Cosmic Velocities</p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-basic-principles-of-gravitational-escape","title":"1.1 Basic Principles of Gravitational Escape","text":"<p>The concept of escape velocity emerges from the principle of energy conservation. For an object to escape a celestial body's gravitational field, its kinetic energy must equal or exceed the gravitational potential energy:</p> \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\] <p>Where: - \\(m\\) is the mass of the escaping object - \\(v\\) is the velocity - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius from the center of the celestial body</p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-the-three-cosmic-velocities","title":"1.2 The Three Cosmic Velocities","text":"<ol> <li>First Cosmic Velocity (Orbital Velocity)</li> <li>For circular orbit: Gravitational force equals centripetal force    $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$</li> <li> <p>Solving for \\(v_1\\):    $$ v_1 = \\sqrt{\\frac{GM}{R}} $$</p> </li> <li> <p>Second Cosmic Velocity (Escape Velocity)</p> </li> <li> <p>From energy conservation:    $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}v_1 $$</p> </li> <li> <p>Third Cosmic Velocity (Solar System Escape Velocity)</p> </li> <li>Combines planetary escape velocity with solar escape velocity:    $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$    where \\(v_{sun}\\) is the orbital velocity around the Sun.</li> </ol> <p>Let's visualize these relationships with Python:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.constants import G\n\n# Set style\nplt.style.use('default')  # Using default style instead of seaborn\ncolors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']  # Custom color palette\n\ndef calculate_velocities(mass, radius, distance_from_sun=None):\n    \"\"\"Calculate cosmic velocities for a celestial body\"\"\"\n    v1 = np.sqrt(G * mass / radius)\n    v2 = np.sqrt(2) * v1\n\n    if distance_from_sun:\n        v_sun = np.sqrt(G * 1.989e30 / distance_from_sun)  # Sun's mass\n        v3 = np.sqrt(v2**2 + v_sun**2)\n        return v1, v2, v3\n    return v1, v2\n\n# Celestial body data (mass in kg, radius in m, distance from sun in m)\nbodies = {\n    \"Earth\": (5.972e24, 6.371e6, 1.496e11),\n    \"Mars\": (6.417e23, 3.389e6, 2.279e11),\n    \"Jupiter\": (1.898e27, 6.9911e7, 7.786e11),\n    \"Moon\": (7.34767309e22, 1.737e6, None),\n    \"Mercury\": (3.285e23, 2.439e6, 5.79e10)\n}\n\n# Calculate velocities\nvelocities = {body: calculate_velocities(mass, radius, dist) \n             for body, (mass, radius, dist) in bodies.items()}\n\n# Create visualization\nfig = plt.figure(figsize=(15, 10))\ngs = plt.GridSpec(2, 2)\n\n# Plot 1: Bar comparison\nax1 = fig.add_subplot(gs[0, :])\nbodies_list = list(bodies.keys())\nv1_vals = [v[0]/1000 for v in velocities.values()]  # Convert to km/s\nv2_vals = [v[1]/1000 for v in velocities.values()]\nv3_vals = [v[2]/1000 if len(v) &gt; 2 else 0 for v in velocities.values()]\n\nx = np.arange(len(bodies_list))\nwidth = 0.25\n\nbars1 = ax1.bar(x - width, v1_vals, width, label='First Cosmic Velocity', color=colors[0])\nbars2 = ax1.bar(x, v2_vals, width, label='Second Cosmic Velocity', color=colors[1])\nbars3 = ax1.bar(x + width, v3_vals, width, label='Third Cosmic Velocity', color=colors[2])\n\nax1.set_ylabel('Velocity (km/s)')\nax1.set_title('Comparison of Cosmic Velocities for Different Celestial Bodies')\nax1.set_xticks(x)\nax1.set_xticklabels(bodies_list)\nax1.legend()\nax1.grid(True, alpha=0.3)\n\n# Plot 2: Velocity vs Radius relationship\nax2 = fig.add_subplot(gs[1, 0])\nradii = np.linspace(1e6, 1e8, 1000)\nmasses = [1e24, 5e24, 1e25]\nfor i, mass in enumerate(masses):\n    v1 = np.sqrt(G * mass / radii)\n    ax2.plot(radii/1000, v1/1000, label=f'Mass = {mass:.1e} kg', color=colors[i])\n\nax2.set_xlabel('Radius (km)')\nax2.set_ylabel('First Cosmic Velocity (km/s)')\nax2.set_title('First Cosmic Velocity vs Radius')\nax2.legend()\nax2.set_xscale('log')\nax2.set_yscale('log')\nax2.grid(True, alpha=0.3)\n\n# Plot 3: Escape velocity field\nax3 = fig.add_subplot(gs[1, 1])\nx = np.linspace(-2, 2, 100)\ny = np.linspace(-2, 2, 100)\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nV = np.sqrt(2*G*5.972e24/(R*6.371e6))/1000  # Earth's escape velocity field\n\ncontour = ax3.contour(X, Y, V, levels=15, colors='black')\nax3.clabel(contour, inline=True, fontsize=8)\nax3.set_title('Earth Escape Velocity Field (km/s)')\nax3.set_xlabel('Distance (Earth Radii)')\nax3.set_ylabel('Distance (Earth Radii)')\nax3.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-analysis-of-results","title":"2. Analysis of Results","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-velocity-relationships","title":"2.1 Velocity Relationships","text":"<p>Let's examine how these velocities vary with distance from a celestial body:</p> <pre><code># Create distance-velocity relationship plot\nplt.figure(figsize=(10, 6))\ndistances = np.linspace(1, 10, 1000)  # In Earth radii\nearth_mass = 5.972e24\nearth_radius = 6.371e6\n\nv1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000\nv2 = np.sqrt(2) * v1\n\nplt.plot(distances, v1, label='First Cosmic Velocity')\nplt.plot(distances, v2, label='Second Cosmic Velocity')\nplt.xlabel('Distance (Earth Radii)')\nplt.ylabel('Velocity (km/s)')\nplt.title('Cosmic Velocities vs Distance from Earth')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-key-observations","title":"2.2 Key Observations","text":"<ol> <li>Inverse Square Relationship: Both first and second cosmic velocities decrease with the square root of distance.</li> <li>Mass Dependence: Larger celestial bodies require higher velocities for escape.</li> <li>Radius Effect: For a given mass, smaller bodies have higher surface escape velocities.</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-applications-in-space-exploration","title":"3. Applications in Space Exploration","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-launch-requirements","title":"3.1 Launch Requirements","text":"<p>Let's visualize the minimum energy requirements for different space missions:</p> <pre><code># Create mission energy requirements visualization\nmissions = {\n    'Low Earth Orbit': 7.8,\n    'Geostationary Orbit': 11.2,\n    'Moon Transfer': 11.2,\n    'Mars Transfer': 11.6,\n    'Solar System Escape': 16.6\n}\n\nplt.figure(figsize=(10, 6))\nplt.barh(list(missions.keys()), list(missions.values()))\nplt.xlabel('Minimum Velocity Required (km/s)')\nplt.title('Velocity Requirements for Space Missions')\nplt.grid(True)\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-practical-considerations","title":"3.2 Practical Considerations","text":"<ul> <li>Atmospheric Drag: Requires additional energy to overcome</li> <li>Gravitational Assists: Can reduce required velocities</li> <li>Orbital Mechanics: Optimal launch windows and trajectories</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-conclusion","title":"4. Conclusion","text":"<p>Understanding cosmic velocities is fundamental to space exploration. The relationships between these velocities help us: - Design efficient launch systems - Plan interplanetary missions - Calculate fuel requirements - Determine optimal trajectories</p> <p>The mathematical framework provided allows us to calculate precise requirements for any celestial body, making it an essential tool in modern space exploration.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/","title":"Problem 3","text":"<p>Trajectories of a Freely Released Payload Near Earth</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","title":"Types of Possible Trajectories","text":"<p>The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are determined by comparing the payload's velocity to key orbital velocities:</p> <ol> <li> <p>First Cosmic Velocity (Circular Orbital Velocity):    $$ v_1 = \\sqrt{\\frac{GM}{r}} $$</p> </li> <li> <p>Second Cosmic Velocity (Escape Velocity):    $$ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2}v_1 $$</p> </li> </ol> <p>where: - \\( G \\) is the gravitational constant - \\( M \\) is Earth's mass - \\( r \\) is the distance from Earth's center</p> <p>Let's visualize these velocities as a function of altitude:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Constants\nG = 6.67430e-11  # Gravitational constant (m^3/kg/s^2)\nM = 5.972e24     # Earth mass (kg)\nR = 6.371e6      # Earth radius (m)\n\n# Calculate velocities at different altitudes\naltitudes = np.linspace(0, 1000000, 1000)  # Altitudes from 0 to 1000 km\nr = R + altitudes\nv1 = np.sqrt(G * M / r)\nv2 = np.sqrt(2 * G * M / r)\n\nplt.figure(figsize=(10, 6))\nplt.plot(altitudes/1000, v1/1000, 'b-', label='Orbital Velocity (v\u2081)')\nplt.plot(altitudes/1000, v2/1000, 'r-', label='Escape Velocity (v\u2082)')\nplt.xlabel('Altitude (km)')\nplt.ylabel('Velocity (km/s)')\nplt.title('Orbital and Escape Velocities vs Altitude')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-classification","title":"Trajectory Classification","text":"<p>The payload's path depends on its velocity relative to these thresholds:</p> <ol> <li>Suborbital (v &lt; v\u2081):</li> <li>Follows a parabolic trajectory</li> <li>Returns to Earth</li> <li> <p>Energy equation: \\( E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} &lt; 0 \\)</p> </li> <li> <p>Circular Orbit (v = v\u2081):</p> </li> <li>Maintains constant altitude</li> <li> <p>Energy equation: \\( E = -\\frac{GMm}{2r} \\)</p> </li> <li> <p>Elliptical Orbit (v\u2081 &lt; v &lt; v\u2082):</p> </li> <li>Closed orbit with varying altitude</li> <li> <p>Energy equation: \\( -\\frac{GMm}{2r} &lt; E &lt; 0 \\)</p> </li> <li> <p>Parabolic Escape (v = v\u2082):</p> </li> <li>Escape trajectory with zero excess velocity</li> <li> <p>Energy equation: \\( E = 0 \\)</p> </li> <li> <p>Hyperbolic Escape (v &gt; v\u2082):</p> </li> <li>Escape trajectory with excess velocity</li> <li>Energy equation: \\( E &gt; 0 \\)</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-analysis","title":"2. Mathematical Analysis","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","title":"Equations of Motion","text":"<p>The motion is governed by Newton's Second Law and Universal Gravitation:</p> \\[ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r} \\] <p>In Cartesian coordinates: $$ \\ddot{x} = -\\frac{GMx}{(x^2 + y^2)^{3/2}} $$ $$ \\ddot{y} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} $$</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conservation-laws","title":"Conservation Laws","text":"<ol> <li> <p>Angular Momentum:    $$ L = mr^2\\dot{\\theta} = \\text{constant} $$</p> </li> <li> <p>Energy:    $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} = \\text{constant} $$</p> </li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computational-analysis","title":"3. Computational Analysis","text":"<p>Let's simulate different trajectory types:</p> <pre><code>import numpy as np\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\n\ndef equations(t, state):\n    x, vx, y, vy = state\n    r = np.sqrt(x**2 + y**2)\n    ax = -G * M * x / r**3\n    ay = -G * M * y / r**3\n    return [vx, ax, vy, ay]\n\ndef simulate_trajectory(v0, angle_deg, altitude=500000):\n    # Initial conditions\n    x0 = R + altitude\n    y0 = 0\n    angle_rad = np.radians(angle_deg)\n    vx0 = v0 * np.cos(angle_rad)\n    vy0 = v0 * np.sin(angle_rad)\n\n    # Time span\n    t_span = (0, 20000)\n    t_eval = np.linspace(0, 20000, 1000)\n\n    # Solve ODE\n    sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], \n                    t_eval=t_eval, method='RK45')\n    return sol.y[0], sol.y[2]\n\n# Plot different trajectories\nplt.figure(figsize=(12, 12))\n\n# Calculate v1 at release altitude\naltitude = 500000\nr = R + altitude\nv1 = np.sqrt(G * M / r)\nv2 = np.sqrt(2 * G * M / r)\n\nvelocities = [0.8*v1, v1, 1.2*v1, v2, 1.2*v2]\nlabels = ['Suborbital', 'Circular', 'Elliptical', \n          'Parabolic', 'Hyperbolic']\nangles = [0, 0, 0, 0, 0]\n\n# Plot Earth\ntheta = np.linspace(0, 2*np.pi, 100)\nearth_x = R * np.cos(theta)\nearth_y = R * np.sin(theta)\nplt.plot(earth_x, earth_y, 'b-', label='Earth')\n\n# Plot trajectories\nfor v, label, angle in zip(velocities, labels, angles):\n    x, y = simulate_trajectory(v, angle)\n    plt.plot(x, y, label=f'{label} (v = {v/1000:.1f} km/s)')\n\nplt.axis('equal')\nplt.grid(True)\nplt.legend()\nplt.title('Different Types of Orbital Trajectories')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-energy-analysis","title":"4. Energy Analysis","text":"<p>Let's analyze the energy distribution for different trajectories:</p> <pre><code>def calculate_energy(x, y, vx, vy):\n    r = np.sqrt(x**2 + y**2)\n    v = np.sqrt(vx**2 + vy**2)\n    KE = 0.5 * v**2\n    PE = -G * M / r\n    return KE, PE, KE + PE\n\n# Plot energy evolution\nplt.figure(figsize=(12, 6))\n\n# Choose one trajectory (elliptical)\nv0 = 1.2 * v1\nt_span = (0, 20000)\nt_eval = np.linspace(0, 20000, 1000)\n\n# Solve ODE with same time points as t_eval\nsol = solve_ivp(equations, t_span, [R + altitude, v0, 0, 0], \n                t_eval=t_eval, method='RK45', rtol=1e-8, atol=1e-8)\n\n# Calculate energies\nKE, PE, E = calculate_energy(sol.y[0], sol.y[2], sol.y[1], sol.y[3])\n\n# Now plot using sol.t instead of t_eval to ensure matching dimensions\nplt.plot(sol.t, KE, 'r-', label='Kinetic Energy')\nplt.plot(sol.t, PE, 'b-', label='Potential Energy')\nplt.plot(sol.t, E, 'g-', label='Total Energy')\nplt.xlabel('Time (s)')\nplt.ylabel('Energy (J/kg)')\nplt.title('Energy Evolution in Elliptical Orbit')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-practical-applications","title":"5. Practical Applications","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-satellite-deployment","title":"1. Satellite Deployment","text":"<ul> <li>Precise velocity control for desired orbit</li> <li>Minimizing orbital corrections</li> <li>Station-keeping requirements</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-reentry-scenarios","title":"2. Reentry Scenarios","text":"<ul> <li>Controlled deorbiting</li> <li>Heat shield requirements</li> <li>Landing point prediction</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-interplanetary-missions","title":"3. Interplanetary Missions","text":"<ul> <li>Escape trajectory design</li> <li>Gravity assist maneuvers</li> <li>Delta-v budgeting</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-conclusion","title":"6. Conclusion","text":"<p>Understanding orbital trajectories is fundamental for: - Mission planning and execution - Risk assessment and mitigation - Optimal resource utilization - Safety of space operations</p> <p>The analysis demonstrates how initial conditions determine the final trajectory, emphasizing the importance of precise calculations in space missions.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/","title":"Problem 1","text":"<p>Interference Patterns on a Water Surface</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","title":"1. Theoretical Background","text":""},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference","title":"Wave Interference","text":"<p>Interference occurs when two or more waves overlap, leading to constructive (amplification) and destructive (cancellation) effects. On a water surface, waves emanating from multiple sources interact to form intricate interference patterns.</p> <p>The displacement \\( \\eta(x, y, t) \\) of a circular wave originating from a point source \\( (x_0, y_0) \\) is given by:</p> \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] <p>where: - \\( A \\) is the wave amplitude, - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the radial distance from the source, - \\( \\phi \\) is the initial phase.</p> <p>When multiple sources are present, the net displacement is given by:</p> \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] <p>where \\( N \\) is the number of sources.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-problem-setup","title":"2. Problem Setup","text":""},{"location":"1%20Physics/3%20Waves/Problem_1/#1-choosing-a-regular-polygon","title":"1. Choosing a Regular Polygon","text":"<p>We select a regular polygon (e.g., equilateral triangle, square, pentagon) and place wave sources at its vertices.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-computing-the-superposition","title":"2. Computing the Superposition","text":"<p>Each vertex of the polygon acts as a wave source, and their combined effect determines the final interference pattern.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-model","title":"3. Computational Model","text":"<p>The following Python script simulates and visualizes the interference pattern.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Define wave parameters\nA = 1  # Amplitude\nlambda_ = 10  # Wavelength\nk = 2 * np.pi / lambda_  # Wave number\nomega = 2 * np.pi  # Angular frequency (arbitrary unit)\nt = 0  # Time snapshot\n\n# Define polygon vertices (square as an example)\nN = 4  # Number of sources (square)\nradius = 20  # Distance from center\nangles = np.linspace(0, 2 * np.pi, N, endpoint=False)\nsources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles]\n\n# Define grid for visualization\nx = np.linspace(-30, 30, 300)\ny = np.linspace(-30, 30, 300)\nX, Y = np.meshgrid(x, y)\n\n# Compute wave interference pattern\neta_sum = np.zeros_like(X)\nfor x0, y0 in sources:\n    R = np.sqrt((X - x0)**2 + (Y - y0)**2)\n    eta_sum += A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t)  # Avoid division by zero\n\n# Plot the interference pattern\nplt.figure(figsize=(8, 6))\nplt.imshow(eta_sum, extent=[-30, 30, -30, 30], cmap='coolwarm', origin='lower')\nplt.colorbar(label='Wave Amplitude')\nplt.scatter(*zip(*sources), color='black', label='Wave Sources')\nplt.legend()\nplt.title('Interference Pattern for a Square Wave Source')\nplt.xlabel('X Position')\nplt.ylabel('Y Position')\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","title":"4. Observations and Analysis","text":"<ol> <li>Constructive Interference: Bright regions indicate where wave crests reinforce each other.</li> <li>Destructive Interference: Dark regions indicate cancellation due to phase differences.</li> <li>Polygonal Symmetry: The interference pattern reflects the symmetry of the chosen polygon.</li> </ol>"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","title":"5. Conclusion","text":"<p>This simulation demonstrates how waves from multiple sources interact to form interference patterns. By varying the polygon shape and wave parameters, we can analyze different wave behaviors useful in acoustics, optics, and fluid dynamics.</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","title":"Problem 1","text":"<p>import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation import matplotlib.gridspec as gridspec</p> <p>def simulate_uniform_B(q, m, B, v0, r0, dt, steps):     \"\"\"Enhanced simulation with energy and momentum tracking\"\"\"     r = np.zeros((steps, 3))     v = np.zeros((steps, 3))     E_kinetic = np.zeros(steps)     angular_momentum = np.zeros((steps, 3))     magnetic_moment = np.zeros(steps)</p> <pre><code>r[0] = r0\nv[0] = v0\n\n# Initial values\nE_kinetic[0] = 0.5 * m * np.sum(v[0]**2)\nangular_momentum[0] = m * np.cross(r[0], v[0])\n\nB_mag = np.linalg.norm(B)\nv_perp = v[0] - np.dot(v[0], B) * B / B_mag**2\nmagnetic_moment[0] = 0.5 * m * np.sum(v_perp**2) / B_mag\n\nfor i in range(1, steps):\n    F = q * np.cross(v[i-1], B)\n    a = F / m\n    v[i] = v[i-1] + a * dt\n    r[i] = r[i-1] + v[i] * dt\n\n    # Calculate conserved quantities\n    E_kinetic[i] = 0.5 * m * np.sum(v[i]**2)\n    angular_momentum[i] = m * np.cross(r[i], v[i])\n    v_perp = v[i] - np.dot(v[i], B) * B / B_mag**2\n    magnetic_moment[i] = 0.5 * m * np.sum(v_perp**2) / B_mag\n\nreturn r, v, E_kinetic, angular_momentum, magnetic_moment\n</code></pre> <p>def simulate_EB_fields(q, m, E, B, v0, r0, dt, steps):     \"\"\"Enhanced E\u00d7B drift simulation with additional physics parameters\"\"\"     r = np.zeros((steps, 3))     v = np.zeros((steps, 3))     drift_velocity = np.zeros((steps, 3))     gyroradius = np.zeros(steps)     total_energy = np.zeros(steps)</p> <pre><code>r[0] = r0\nv[0] = v0\n\nB_mag = np.linalg.norm(B)\ndrift_velocity_theoretical = np.cross(E, B) / (B_mag**2)\n\nfor i in range(1, steps):\n    F = q * (E + np.cross(v[i-1], B))\n    a = F / m\n    v[i] = v[i-1] + a * dt\n    r[i] = r[i-1] + v[i] * dt\n\n    # Calculate drift velocity and gyroradius\n    v_perp = v[i] - np.dot(v[i], B) * B / (B_mag**2)\n    drift_velocity[i] = np.cross(E, B) / (B_mag**2)\n    gyroradius[i] = m * np.linalg.norm(v_perp) / (abs(q) * B_mag)\n\n    # Calculate total energy (kinetic + potential)\n    total_energy[i] = 0.5 * m * np.sum(v[i]**2) + q * np.dot(E, r[i])\n\nreturn r, v, drift_velocity, gyroradius, total_energy\n</code></pre>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","title":"Parameters","text":"<p>q = 1.6e-19  # electron charge m = 9.1e-31  # electron mass B = np.array([0, 0, 0.1])  # magnetic field in T E = np.array([1000, 0, 0])  # electric field in V/m v0 = np.array([1e6, 1e6, 0])  # initial velocity r0 = np.array([0, 0, 0])  # initial position dt = 1e-11 steps = 1000</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#run-simulations","title":"Run simulations","text":"<p>r_B, v_B, E_kin, L, mu = simulate_uniform_B(q, m, B, v0, r0, dt, steps) r_EB, v_EB, v_drift, rg, E_total = simulate_EB_fields(q, m, E, B, v0, r0, dt, steps)</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#create-comprehensive-visualization-with-8-subplots","title":"Create comprehensive visualization with 8 subplots","text":"<p>plt.style.use('seaborn-darkgrid') fig = plt.figure(figsize=(20, 15)) gs = gridspec.GridSpec(4, 2)</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-3d-trajectory-in-b-field","title":"1. 3D trajectory in B field","text":"<p>ax1 = fig.add_subplot(gs[0, 0], projection='3d') ax1.plot(r_B[:, 0], r_B[:, 1], r_B[:, 2], 'b-', label='Trajectory') ax1.set_title('3D Particle Trajectory (B field)') ax1.set_xlabel('X (m)') ax1.set_ylabel('Y (m)') ax1.set_zlabel('Z (m)') ax1.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-energy-conservation-in-b-field","title":"2. Energy conservation in B field","text":"<p>ax2 = fig.add_subplot(gs[0, 1]) t = np.arange(steps) * dt ax2.plot(t, E_kin / E_kin[0], 'g-', label='Normalized Kinetic Energy') ax2.set_title('Energy Conservation (B field)') ax2.set_xlabel('Time (s)') ax2.set_ylabel('E/E\u2080') ax2.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-eb-drift-trajectory","title":"3. E\u00d7B drift trajectory","text":"<p>ax3 = fig.add_subplot(gs[1, 0], projection='3d') ax3.plot(r_EB[:, 0], r_EB[:, 1], r_EB[:, 2], 'r-', label='E\u00d7B Drift') ax3.set_title('3D Particle Trajectory (E\u00d7B fields)') ax3.set_xlabel('X (m)') ax3.set_ylabel('Y (m)') ax3.set_zlabel('Z (m)') ax3.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-total-energy-in-eb-fields","title":"4. Total energy in E\u00d7B fields","text":"<p>ax4 = fig.add_subplot(gs[1, 1]) ax4.plot(t, E_total / E_total[0], 'm-', label='Normalized Total Energy') ax4.set_title('Total Energy Conservation (E\u00d7B fields)') ax4.set_xlabel('Time (s)') ax4.set_ylabel('E_total/E\u2080') ax4.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-magnetic-moment-conservation","title":"5. Magnetic moment conservation","text":"<p>ax5 = fig.add_subplot(gs[2, 0]) ax5.plot(t, mu / mu[0], 'c-', label='Normalized Magnetic Moment') ax5.set_title('Magnetic Moment Conservation') ax5.set_xlabel('Time (s)') ax5.set_ylabel('\u03bc/\u03bc\u2080') ax5.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-angular-momentum-components","title":"6. Angular momentum components","text":"<p>ax6 = fig.add_subplot(gs[2, 1]) ax6.plot(t, L[:, 0], 'b-', label='Lx') ax6.plot(t, L[:, 1], 'r-', label='Ly') ax6.plot(t, L[:, 2], 'g-', label='Lz') ax6.set_title('Angular Momentum Components') ax6.set_xlabel('Time (s)') ax6.set_ylabel('Angular Momentum (kg\u22c5m\u00b2/s)') ax6.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-phase-space-plot-x-vx","title":"7. Phase space plot (x-vx)","text":"<p>ax7 = fig.add_subplot(gs[3, 0]) ax7.plot(r_B[:, 0], v_B[:, 0], 'k.', markersize=1, label='Phase Space') ax7.set_title('Phase Space (x-vx)') ax7.set_xlabel('Position x (m)') ax7.set_ylabel('Velocity vx (m/s)') ax7.legend()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-gyroradius-evolution","title":"8. Gyroradius evolution","text":"<p>ax8 = fig.add_subplot(gs[3, 1]) ax8.plot(t, rg * 1e6, 'y-', label='Gyroradius') ax8.set_title('Gyroradius Evolution') ax8.set_xlabel('Time (s)') ax8.set_ylabel('Radius (\u03bcm)') ax8.legend()</p> <p>plt.tight_layout() plt.show()</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#additional-theoretical-analysis-and-formulas","title":"Additional theoretical analysis and formulas:","text":"<p>\"\"\" Key Physics Formulas and Concepts:</p> <ol> <li> <p>Cyclotron Frequency:    \u03c9_c = qB/m</p> </li> <li> <p>Larmor Radius:    r_L = mv_\u22a5/(qB)</p> </li> <li> <p>E\u00d7B Drift Velocity:    v_d = (E\u00d7B)/B\u00b2</p> </li> <li> <p>Magnetic Moment (First Adiabatic Invariant):    \u03bc = mv_\u22a5\u00b2/(2B)</p> </li> <li> <p>Drift Velocities:</p> </li> <li>Gradient B drift: v_\u2207B = (mv_\u22a5\u00b2/2qB\u00b3)(B\u00d7\u2207B)</li> <li>Curvature drift: v_c = (mv_\u2225\u00b2/qB\u00b3)R_c\u00d7B</li> <li> <p>Polarization drift: v_p = (m/qB\u00b2)dE_\u22a5/dt</p> </li> <li> <p>Energy Conservation:    d/dt(\u00bdmv\u00b2) = qE\u00b7v</p> </li> <li> <p>Canonical Momentum:    P = mv + qA (A is vector potential)</p> </li> <li> <p>Magnetic Mirror Force:    F_\u2225 = -\u03bc\u2207_\u2225B</p> </li> <li> <p>Mirror Ratio and Loss Cone:    R = B_max/B_min    sin\u00b2(\u03b8) &gt; 1/R (trapping condition)</p> </li> <li> <p>Relativistic Effects:</p> <ul> <li>Relativistic mass: m = \u03b3m\u2080</li> <li>Lorentz factor: \u03b3 = 1/\u221a(1-v\u00b2/c\u00b2)</li> <li>Relativistic cyclotron frequency: \u03c9_c = qB/(\u03b3m\u2080) \"\"\" </li> </ul> </li> </ol>"},{"location":"1%20Physics/5%20Circuits/Problem_1/","title":"Problem 1","text":"<p>Equivalent Resistance Using Graph Theory</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-theoretical-background","title":"1. Theoretical Background","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-theory-in-circuit-analysis","title":"Graph Theory in Circuit Analysis","text":"<p>In electrical circuit analysis, we can represent circuits as graphs where: - Nodes (vertices) represent junctions - Edges represent resistors - Edge weights represent resistance values</p> <p>The equivalent resistance \\( R_{eq} \\) between two points in a circuit can be calculated using graph-theoretic methods. This approach is particularly powerful for complex circuits where traditional series-parallel reduction becomes cumbersome.</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>For a circuit with \\(n\\) nodes and \\(m\\) resistors, we can use:</p> <ol> <li> <p>Kirchhoff's Current Law (KCL): [ \\sum_{k=1}^{n} I_k = 0 ]</p> </li> <li> <p>Kirchhoff's Voltage Law (KVL): [ \\sum_{k=1}^{m} V_k = 0 ]</p> </li> <li> <p>Ohm's Law for each resistor: [ V = IR ]</p> </li> </ol> <p>The conductance matrix \\(G\\) of the circuit is given by:</p> \\[ G_{ij} = \\begin{cases} \\sum_{k} \\frac{1}{R_k} &amp; \\text{if } i = j \\\\ -\\frac{1}{R_{ij}} &amp; \\text{if } i \\text{ and } j \\text{ are connected} \\\\ 0 &amp; \\text{otherwise} \\end{cases} \\]"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-implementation","title":"2. Algorithm Implementation","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#basic-implementation","title":"Basic Implementation","text":"<p>Here's a Python implementation using NetworkX to handle graph operations:</p> <p>```python import networkx as nx import numpy as np import matplotlib.pyplot as plt</p> <p>class CircuitSolver:     def init(self):         self.G = nx.Graph()</p> <pre><code>def add_resistor(self, node1, node2, resistance):\n    \"\"\"Add a resistor between two nodes.\"\"\"\n    self.G.add_edge(node1, node2, weight=resistance)\n\ndef get_conductance_matrix(self):\n    \"\"\"Generate the conductance matrix for the circuit.\"\"\"\n    n = self.G.number_of_nodes()\n    G_matrix = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                # Diagonal elements: sum of conductances\n                for neighbor in self.G.neighbors(i):\n                    G_matrix[i,i] += 1/self.G[i][neighbor]['weight']\n            elif self.G.has_edge(i,j):\n                # Off-diagonal elements: negative conductance\n                G_matrix[i,j] = -1/self.G[i][j]['weight']\n\n    return G_matrix\n\ndef calculate_equivalent_resistance(self, source, sink):\n    \"\"\"Calculate equivalent resistance between two nodes.\"\"\"\n    n = self.G.number_of_nodes()\n    G_matrix = self.get_conductance_matrix()\n\n    # Remove one row and column to make matrix non-singular\n    G_reduced = np.delete(np.delete(G_matrix, sink, 0), sink, 1)\n\n    # Create current vector (1A entering source, -1A leaving sink)\n    i = np.zeros(n-1)\n    if source &lt; sink:\n        i[source] = 1\n    else:\n        i[source-1] = 1\n\n    # Solve for node voltages\n    v = np.linalg.solve(G_reduced, i)\n\n    # Calculate equivalent resistance (voltage difference / current)\n    # Since we're using 1A current, the voltage difference is equal to the resistance\n    if source &lt; sink:\n        return abs(v[source] - 0)  # sink voltage is 0 by our reference\n    else:\n        return abs(v[source-1] - 0)\n\ndef visualize_circuit(self, ax=None, title=\"Circuit Graph\"):\n    \"\"\"Visualize the circuit graph.\n\n    Args:\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. If None, creates new figure\n        title (str): Title for the plot\n    \"\"\"\n    if ax is None:\n        plt.figure(figsize=(10, 8))\n        ax = plt.gca()\n\n    pos = nx.spring_layout(self.G)\n\n    # Draw nodes\n    nx.draw_networkx_nodes(self.G, pos, node_color='lightblue', \n                         node_size=500, ax=ax)\n\n    # Draw edges with resistance labels\n    nx.draw_networkx_edges(self.G, pos, ax=ax)\n    edge_labels = nx.get_edge_attributes(self.G, 'weight')\n    nx.draw_networkx_edge_labels(self.G, pos, edge_labels)\n\n    # Draw node labels\n    nx.draw_networkx_labels(self.G, pos)\n\n    ax.set_title(title)\n    ax.axis('off')\n</code></pre> <p>def test_circuits():     # Import matplotlib if not already imported     import matplotlib.pyplot as plt</p> <pre><code># Create figure with subplots\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\nax1, ax2, ax3 = axes  # Unpack the axes array\n\n# Test Case 1: Simple Series Circuit\nprint(\"Test Case 1: Simple Series Circuit\")\ncs1 = CircuitSolver()\ncs1.add_resistor(0, 1, 2)\ncs1.add_resistor(1, 2, 3)\nr1 = cs1.calculate_equivalent_resistance(0, 2)\nprint(f\"Equivalent Resistance: {r1}\u03a9\")\ncs1.visualize_circuit(ax1, f\"Series Circuit\\nReq = {r1:.1f}\u03a9\")\n\n# Test Case 2: Simple Parallel Circuit\nprint(\"\\nTest Case 2: Simple Parallel Circuit\")\ncs2 = CircuitSolver()\ncs2.add_resistor(0, 1, 4)\ncs2.add_resistor(0, 1, 4)\nr2 = cs2.calculate_equivalent_resistance(0, 1)\nprint(f\"Equivalent Resistance: {r2}\u03a9\")\ncs2.visualize_circuit(ax2, f\"Parallel Circuit\\nReq = {r2:.1f}\u03a9\")\n\n# Test Case 3: Complex Bridge Circuit\nprint(\"\\nTest Case 3: Wheatstone Bridge Circuit\")\ncs3 = CircuitSolver()\ncs3.add_resistor(0, 1, 2)\ncs3.add_resistor(1, 2, 2)\ncs3.add_resistor(2, 3, 2)\ncs3.add_resistor(0, 4, 2)\ncs3.add_resistor(4, 3, 2)\ncs3.add_resistor(1, 4, 3)\nr3 = cs3.calculate_equivalent_resistance(0, 3)\nprint(f\"Equivalent Resistance: {r3}\u03a9\")\ncs3.visualize_circuit(ax3, f\"Wheatstone Bridge\\nReq = {r3:.1f}\u03a9\")\n\n# Adjust layout and display\nplt.tight_layout()\nplt.show()\n</code></pre> <p>if name == \"main\":     test_circuits()</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-analysis-of-results","title":"3. Analysis of Results","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-case-results","title":"Test Case Results","text":"<ol> <li>Series Circuit:</li> <li>Expected: \\(R_{eq} = R_1 + R_2 = 5\\Omega\\)</li> <li> <p>Calculated: \\(5\\Omega\\)</p> </li> <li> <p>Parallel Circuit:</p> </li> <li>Expected: \\(R_{eq} = \\frac{R_1R_2}{R_1 + R_2} = 2\\Omega\\)</li> <li> <p>Calculated: \\(2\\Omega\\)</p> </li> <li> <p>Wheatstone Bridge:</p> </li> <li>More complex calculation</li> <li>Demonstrates the power of graph-theoretic approach</li> </ol>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-efficiency","title":"Algorithm Efficiency","text":"<p>The algorithm's complexity is dominated by: 1. Matrix operations: \\(O(n^3)\\) for solving linear equations 2. Graph operations: \\(O(E)\\) for building conductance matrix</p> <p>Where: - \\(n\\) is the number of nodes - \\(E\\) is the number of edges (resistors)</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-conclusion","title":"4. Conclusion","text":"<p>The graph-theoretic approach to calculating equivalent resistance offers several advantages:</p> <ol> <li>Systematic: Handles complex circuits methodically</li> <li>Generalizable: Works for any circuit topology</li> <li>Automatable: Easy to implement in software</li> <li>Scalable: Can handle large circuits efficiently</li> </ol> <p>This method bridges the gap between electrical circuit theory and graph theory, demonstrating the power of mathematical abstraction in solving physical problems.</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-further-improvements","title":"5. Further Improvements","text":"<p>Possible enhancements to the current implementation:</p> <ol> <li>Add support for voltage and current sources</li> <li>Implement parallel processing for large circuits</li> <li>Add error handling for singular matrices</li> <li>Optimize matrix operations for sparse circuits</li> </ol> <p> </p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/","title":"Problem 1","text":""},{"location":"1%20Physics/6%20Statistics/Problem_2/","title":"Problem 2","text":""},{"location":"1%20Physics/7%20Measurements/Problem_1/","title":"Problem 1","text":""},{"location":"2%20Mathematics/1%20Linear_algebra/","title":"Linear Algebra","text":""},{"location":"2%20Mathematics/2%20Analytic_geometry/","title":"Analytic geometry","text":""},{"location":"2%20Mathematics/3%20Calculus/","title":"Calculus","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","title":"Set Theory","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","title":"Relations","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","title":"Functions","text":""},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","title":"Combinatorics","text":""},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","title":"Number Theory","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","title":"Sequences and Series","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","title":"Induction","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","title":"Recurrence","text":""},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","title":"Graph Theory","text":""},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","title":"Logic","text":""}]}