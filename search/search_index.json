{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#technical-setup","title":"Technical setup","text":"<ul> <li>Install Visual Studio Code from here</li> <li>Install folowing extensions in Visual Studio Code:<ul> <li>Github Repositories (GitHub, Inc.)</li> <li>GitHub Copilot (GitHub Copilot)</li> <li>GitHub Actions (GitHub, Inc.)</li> <li>Python (Microsoft)</li> </ul> </li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Python</li> <li>Miniconda Documentation</li> <li>Google Colab</li> </ul>"},{"location":"#how-to-use-this-repository","title":"How to use this repository","text":"<p>Below are the steps you need to follow:</p> <ol> <li>Create a GitHub account if you don\u2019t have one.</li> <li>Fork this repository to your account. </li> <li>Enable the Issues tab:<ul> <li>Go to the <code>Settings</code> tab and check the Issues option. </li> </ul> </li> <li>Add your professor as a collaborator:<ul> <li>Go to the <code>Settings</code> tab and add their GitHub username in the Collaborators section. </li> </ul> </li> <li>Install python: Download</li> </ol> <p>Source Code &amp; WWW</p> <ul> <li>GitHub repo</li> <li>WWW</li> </ul>"},{"location":"#where-can-i-find-the-problems","title":"Where can I find the problems?","text":"<p>Please visit the Mathematics Physics Lectures website.</p> <ul> <li>Physics</li> <li>Mathematics</li> <li>Discret Mathematics</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","title":"Problem 1","text":"<p>Investigating the Range as a Function of the Angle of Projection</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","title":"Governing Equations of Motion","text":"<p>Projectile motion can be analyzed using Newton's laws of motion. For a more complete analysis, let's start with the fundamental differential equations:</p> \\[ \\frac{d^2x}{dt^2} = 0 \\] \\[ \\frac{d^2y}{dt^2} = -g \\] <p>Integrating these equations with initial conditions: $$ v_{0x} = v_0\\cos(\\theta) $$</p> \\[ v_{0y} = v_0\\sin(\\theta) \\] <p>We get the velocity components: $$ v_x(t) = v_0\\cos(\\theta) $$</p> \\[ v_y(t) = v_0\\sin(\\theta) - gt \\] <p>And the position components: $$ x(t) = v_0\\cos(\\theta)t $$</p> \\[ y(t) = v_0\\sin(\\theta)t - \\frac{1}{2}gt^2 \\]"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhanced-analysis-of-flight-characteristics","title":"Enhanced Analysis of Flight Characteristics","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","title":"Maximum Height:","text":"<p>The maximum height occurs when \\(v_y(t) = 0\\): $$ h_{max} = \\frac{v_0^2\\sin^2(\\theta)}{2g} $$</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","title":"Time of Flight:","text":"\\[ t_f = \\frac{2v_0\\sin(\\theta)}{g} \\]"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","title":"Range Formula:","text":"\\[ R = \\frac{v_0^2\\sin(2\\theta)}{g} \\] <p>Let's create a more comprehensive visualization that shows both the trajectory and range analysis:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\ndef trajectory(t, v0, theta, g=9.81):\n    x = v0 * np.cos(np.radians(theta)) * t\n    y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2\n    return x, y\n\ndef range_function(theta, v0, g=9.81):\n    return (v0**2 * np.sin(2 * np.radians(theta))) / g\n\n# Parameters\nv0 = 20  # initial velocity in m/s\ng = 9.81  # gravity\n\n# Create figure with GridSpec\nfig = plt.figure(figsize=(15, 10))\ngs = GridSpec(2, 2, figure=fig)\n\n# Plot 1: Range vs Angle\nax1 = fig.add_subplot(gs[0, 0])\ntheta = np.linspace(0, 90, 100)\nranges = range_function(theta, v0, g)\nax1.plot(theta, ranges, 'b-', label=f'v0 = {v0} m/s')\nax1.set_xlabel('Launch Angle (degrees)')\nax1.set_ylabel('Range (m)')\nax1.set_title('Range vs Launch Angle')\nax1.grid(True)\nax1.legend()\n\n# Plot 2: Multiple Trajectories\nax2 = fig.add_subplot(gs[0, 1])\nangles = [15, 30, 45, 60, 75]\nt = np.linspace(0, 3, 100)\nfor angle in angles:\n    x, y = trajectory(t, v0, angle)\n    ax2.plot(x, y, label=f'\u03b8 = {angle}\u00b0')\nax2.set_xlabel('Distance (m)')\nax2.set_ylabel('Height (m)')\nax2.set_title('Projectile Trajectories')\nax2.grid(True)\nax2.legend()\n\n# Plot 3: Range vs Initial Velocity\nax3 = fig.add_subplot(gs[1, 0])\nv0_range = np.linspace(0, 30, 100)\ntheta_fixed = 45  # optimal angle\nranges_v0 = range_function(theta_fixed, v0_range)\nax3.plot(v0_range, ranges_v0, 'r-')\nax3.set_xlabel('Initial Velocity (m/s)')\nax3.set_ylabel('Range (m)')\nax3.set_title('Range vs Initial Velocity (\u03b8 = 45\u00b0)')\nax3.grid(True)\n\n# Plot 4: Maximum Height vs Angle\nax4 = fig.add_subplot(gs[1, 1])\nh_max = (v0**2 * np.sin(np.radians(theta))**2) / (2*g)\nax4.plot(theta, h_max, 'g-')\nax4.set_xlabel('Launch Angle (degrees)')\nax4.set_ylabel('Maximum Height (m)')\nax4.set_title('Maximum Height vs Launch Angle')\nax4.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#advanced-analysis-with-air-resistance","title":"Advanced Analysis with Air Resistance","text":"<p>When considering air resistance, the equations become:</p> \\[ m\\frac{d^2x}{dt^2} = -kv_x|v| $$ $$ m\\frac{d^2y}{dt^2} = -mg - kv_y|v| \\] <p>where \\(k\\) is the drag coefficient and \\(|v|\\) is the magnitude of velocity.</p> <p>Let's simulate this using numerical integration:</p> <pre><code>from scipy.integrate import odeint\n\ndef projectile_with_drag(state, t, k, m, g):\n    x, y, vx, vy = state\n    v = np.sqrt(vx**2 + vy**2)\n\n    dxdt = vx\n    dydt = vy\n    dvxdt = -k/m * vx * v\n    dvydt = -g - k/m * vy * v\n\n    return [dxdt, dydt, dvxdt, dvydt]\n\n# Parameters\nm = 1.0  # mass in kg\nk = 0.1  # drag coefficient\nt = np.linspace(0, 2, 1000)\ntheta = 45  # degrees\n\n# Initial conditions\nv0 = 20\nstate0 = [0, 0, v0*np.cos(np.radians(theta)), v0*np.sin(np.radians(theta))]\n\n# Solve ODE\nsolution = odeint(projectile_with_drag, state0, t, args=(k, m, g))\n\nplt.figure(figsize=(10, 6))\nplt.plot(solution[:, 0], solution[:, 1], 'b-', label='With drag')\nx_no_drag, y_no_drag = trajectory(t, v0, theta)\nplt.plot(x_no_drag, y_no_drag, 'r--', label='Without drag')\nplt.xlabel('Distance (m)')\nplt.ylabel('Height (m)')\nplt.title('Comparison of Trajectories With and Without Air Resistance')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","title":"2. Analysis of the Range","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","title":"Influence of Initial Conditions","text":"<ul> <li>Initial velocity (\\( v_0 \\)): Increasing \\( v_0 \\) increases the range quadratically.</li> <li>Gravitational acceleration (\\( g \\)): Higher \\( g \\) reduces the range, as the projectile falls more quickly.</li> <li>Launch angle (\\( \\theta \\)): The range follows a symmetric pattern, peaking at \\( 45^\\circ \\).</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","title":"Graphical Representation","text":"<p>Below is a Python script to visualize how the range changes with \\( \\theta \\):</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndef range_function(theta, v0, g=9.81):\n    return (v0**2 * np.sin(2 * np.radians(theta))) / g\n\n# Parameters\nv0 = 20  # initial velocity in m/s\ntheta = np.linspace(0, 90, 100)  # range of angles\ng = 9.81  # gravity\n\n# Compute ranges\nranges = range_function(theta, v0, g)\n\n# Plot results\nplt.figure(figsize=(8,5))\nplt.plot(theta, ranges, label=f'v0 = {v0} m/s')\nplt.xlabel('Launch Angle (degrees)')\nplt.ylabel('Range (m)')\nplt.title('Projectile Range vs. Launch Angle')\nplt.legend()\nplt.grid()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","title":"3. Practical Applications","text":"<ul> <li>Sports: Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin.</li> <li>Engineering: Used in ballistics, military applications, and designing trajectories for rockets and missiles.</li> <li>Astrophysics: Used to model celestial body trajectories and space exploration missions.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","title":"4. Implementation","text":"<p>A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-air-resistance","title":"Example: Adding Air Resistance","text":"<p>The equations with drag \\(F_d = -k v^2\\) lead to:</p> \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] <p>A numerical solver like Python's SciPy can be used to compute solutions.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","title":"5. Limitations and Further Considerations","text":"<ul> <li>Air resistance: Causes asymmetry and reduces range.</li> <li>Uneven terrain: Requires solving for complex boundary conditions.</li> <li>Wind effects: Affects trajectory unpredictably.</li> </ul> <p>Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","title":"Conclusion","text":"<p>Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","title":"Problem 2","text":"<p>Investigating the Dynamics of a Forced Damped Pendulum</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","title":"Governing Equation","text":"<p>The motion of a forced damped pendulum is governed by the nonlinear differential equation:</p> \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] <p>where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angles","title":"Approximate Solutions for Small Angles","text":"<p>For small angles (\\( \\theta \\approx \\sin \\theta \\)), the equation simplifies to:</p> \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] <p>This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form:</p> \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] <p>where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\), and system parameters.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","title":"Resonance Conditions","text":"<p>Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\), leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","title":"2. Analysis of Dynamics","text":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-system-parameters","title":"Influence of System Parameters","text":"<ul> <li>Damping Coefficient (\\( b \\)): Higher damping suppresses oscillations and prevents chaotic motion.</li> <li>Driving Amplitude (\\( A \\)): Larger amplitudes can induce chaotic behavior and bifurcations.</li> <li>Driving Frequency (\\( \\omega \\)): At specific values, resonance or chaos can emerge.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","title":"Transition to Chaos","text":"<p>By varying \\( A \\) and \\( \\omega \\), the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using:</p> <ul> <li>Phase Diagrams: Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability.</li> <li>Poincar\u00e9 Sections: Discrete-time slices revealing periodicity or chaos.</li> <li>Bifurcation Diagrams: Showing system behavior changes as parameters vary.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","title":"3. Practical Applications","text":"<p>The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices: Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges: Helps in understanding oscillations leading to structural failures. - Electrical Circuits: Analogous to driven RLC circuits with damping and external forcing.</p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","title":"4. Implementation","text":"<p>Below is a Python script to simulate and visualize the forced damped pendulum.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef forced_damped_pendulum(t, y, b, g, L, A, omega):\n    theta, omega_dot = y\n    dtheta_dt = omega_dot\n    domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t)\n    return [dtheta_dt, domega_dt]\n\n# Enhanced parameter set\nb_values = [0.1, 0.5, 1.0]  # different damping coefficients\ng = 9.81  # gravity (m/s^2)\nL = 1.0   # pendulum length (m)\nA = 1.2   # driving force amplitude\nomega = 2.0  # driving frequency\ny0 = [0.1, 0]  # initial conditions: [theta(0), omega(0)]\nt_span = (0, 50)\nt_eval = np.linspace(0, 50, 1000)\n\n# Create subplots for different analyses\nplt.figure(figsize=(15, 10))\n\n# Plot 1: Compare different damping coefficients\nplt.subplot(2, 2, 1)\nfor b in b_values:\n    sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                    args=(b, g, L, A, omega))\n    plt.plot(sol.t, sol.y[0], label=f'b = {b}')\nplt.xlabel('Time (s)')\nplt.ylabel('Angle (rad)')\nplt.title('Effect of Damping Coefficient')\nplt.legend()\nplt.grid(True)\n\n# Plot 2: Phase Space Portrait\nplt.subplot(2, 2, 2)\nb = 0.2  # Use moderate damping for phase space\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\nplt.plot(sol.y[0], sol.y[1])\nplt.xlabel('\u03b8 (rad)')\nplt.ylabel('d\u03b8/dt (rad/s)')\nplt.title('Phase Space Portrait')\nplt.grid(True)\n\n# Plot 3: Resonance Analysis\nfrequencies = np.linspace(0.5, 4, 50)\namplitudes = []\nb = 0.2\nfor w in frequencies:\n    sol = solve_ivp(forced_damped_pendulum, (0, 100), y0, t_eval=np.linspace(80, 100, 200), \n                    args=(b, g, L, A, w))\n    amplitudes.append(np.max(np.abs(sol.y[0])))\n\nplt.subplot(2, 2, 3)\nplt.plot(frequencies, amplitudes)\nplt.xlabel('Driving Frequency \u03c9 (rad/s)')\nplt.ylabel('Maximum Amplitude (rad)')\nplt.title('Resonance Curve')\nplt.grid(True)\n\n# Plot 4: Energy Analysis\ndef system_energy(theta, omega, L, g):\n    kinetic = 0.5 * L**2 * omega**2\n    potential = g * L * (1 - np.cos(theta))\n    return kinetic + potential\n\nb = 0.2\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\nenergies = [system_energy(theta, omega, L, g) \n           for theta, omega in zip(sol.y[0], sol.y[1])]\n\nplt.subplot(2, 2, 4)\nplt.plot(sol.t, energies)\nplt.xlabel('Time (s)')\nplt.ylabel('Total Energy (J)')\nplt.title('System Energy Evolution')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# 3D Phase Space Trajectory\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(111, projection='3d')\n\nb = 0.2\nsol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, \n                args=(b, g, L, A, omega))\n\nax.plot(sol.y[0], sol.y[1], sol.t)\nax.set_xlabel('\u03b8 (rad)')\nax.set_ylabel('d\u03b8/dt (rad/s)')\nax.set_zlabel('Time (s)')\nax.set_title('3D Phase Space Trajectory')\nplt.show()\n\n# Poincar\u00e9 Section\nplt.figure(figsize=(8, 8))\nt_long = np.linspace(0, 200, 4000)\nsol = solve_ivp(forced_damped_pendulum, (0, 200), y0, t_eval=t_long, \n                args=(b, g, L, A, omega))\n\n# Sample points at driving period\nperiod = 2*np.pi/omega\nindices = [i for i in range(len(t_long)) \n          if abs((t_long[i] % period)) &lt; 0.1]\n\nplt.scatter(sol.y[0][indices], sol.y[1][indices], s=1)\nplt.xlabel('\u03b8 (rad)')\nplt.ylabel('d\u03b8/dt (rad/s)')\nplt.title('Poincar\u00e9 Section')\nplt.grid(True)\nplt.show()\n</code></pre> <p>This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time.</p> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","title":"5. Limitations and Extensions","text":"<ul> <li>Limitations: Assumes a point mass pendulum, ignores friction and air resistance.</li> <li>Extensions: </li> <li>Nonlinear damping (e.g., air drag proportional to velocity squared).</li> <li>Non-periodic driving forces to model irregular forcing.</li> <li>Coupled pendulum systems for synchronization studies.</li> </ul>"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","title":"6. Conclusion","text":"<p>The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/","title":"Problem 1","text":"<p>Orbital Period and Orbital Radius</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-basic-principles","title":"1.1 Basic Principles","text":"<p>The relationship between orbital period and radius emerges from two fundamental principles: 1. Newton's Law of Universal Gravitation 2. Centripetal Force</p> <p>For a body in circular orbit:</p> \\[ F_g = F_c \\] \\[ \\frac{GMm}{r^2} = m\\frac{v^2}{r} \\] <p>where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-derivation-of-keplers-third-law","title":"1.2 Derivation of Kepler's Third Law","text":"<p>For circular orbits, the velocity can be expressed as:</p> \\[ v = \\frac{2\\pi r}{T} \\] <p>Substituting this into the force equation:</p> \\[ \\frac{GMm}{r^2} = m\\frac{4\\pi^2r^2}{T^2r} \\] <p>Simplifying:</p> \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] <p>This is Kepler's Third Law in its exact form, showing that:</p> \\[ T^2 \\propto r^3 \\]"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-computational-analysis","title":"2. Computational Analysis","text":"<p>Let's create a comprehensive visualization suite to analyze orbital dynamics:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib.gridspec import GridSpec\n\n# Constants\nG = 6.67430e-11  # Gravitational constant\nM_earth = 5.972e24  # Earth mass in kg\nM_sun = 1.989e30  # Sun mass in kg\n\ndef orbital_period(radius, central_mass):\n    return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass))\n\ndef plot_orbit_3d(ax, radius, num_points=100):\n    theta = np.linspace(0, 2*np.pi, num_points)\n    x = radius * np.cos(theta)\n    y = radius * np.sin(theta)\n    z = np.zeros_like(theta)\n    ax.plot(x, y, z)\n\n# Create figure with multiple subplots\nfig = plt.figure(figsize=(15, 12))\ngs = GridSpec(2, 2, figure=fig)\n\n# Plot 1: T\u00b2 vs r\u00b3 relationship\nax1 = fig.add_subplot(gs[0, 0])\nradii = np.linspace(1e8, 1e9, 100)\nperiods = orbital_period(radii, M_earth)\nT_squared = periods**2\nr_cubed = radii**3\n\nax1.plot(r_cubed, T_squared, 'b-', label='Earth Satellites')\nax1.set_xlabel('Orbital Radius Cubed (m\u00b3)')\nax1.set_ylabel('Period Squared (s\u00b2)')\nax1.set_title(\"Kepler's Third Law Verification\")\nax1.grid(True)\nax1.legend()\n\n# Plot 2: 3D Orbital Visualization\nax2 = fig.add_subplot(gs[0, 1], projection='3d')\nradii_3d = [4e8, 6e8, 8e8]\ncolors = ['b', 'g', 'r']\n\nfor r, c in zip(radii_3d, colors):\n    plot_orbit_3d(ax2, r)\nax2.scatter([0], [0], [0], color='yellow', s=100, label='Earth')\nax2.set_xlabel('X (m)')\nax2.set_ylabel('Y (m)')\nax2.set_zlabel('Z (m)')\nax2.set_title('3D Visualization of Circular Orbits')\n\n# Plot 3: Orbital Velocity vs Radius\nax3 = fig.add_subplot(gs[1, 0])\nradii_v = np.linspace(1e7, 1e9, 100)\nvelocities = np.sqrt(G * M_earth / radii_v)\n\nax3.plot(radii_v, velocities, 'r-')\nax3.set_xlabel('Orbital Radius (m)')\nax3.set_ylabel('Orbital Velocity (m/s)')\nax3.set_title('Orbital Velocity vs Radius')\nax3.grid(True)\n\n# Plot 4: Energy Analysis\nax4 = fig.add_subplot(gs[1, 1])\nkinetic_energy = 0.5 * velocities**2\npotential_energy = -G * M_earth / radii_v\ntotal_energy = kinetic_energy + potential_energy\n\nax4.plot(radii_v, kinetic_energy, 'b-', label='Kinetic Energy')\nax4.plot(radii_v, potential_energy, 'r-', label='Potential Energy')\nax4.plot(radii_v, total_energy, 'g-', label='Total Energy')\nax4.set_xlabel('Orbital Radius (m)')\nax4.set_ylabel('Energy per unit mass (J/kg)')\nax4.set_title('Orbital Energy Analysis')\nax4.grid(True)\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications","title":"3. Real-World Applications","text":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-satellite-orbits","title":"3.1 Satellite Orbits","text":"<p>Let's analyze different types of satellite orbits:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Constants for common satellite orbits\nLEO_height = 400e3  # Low Earth Orbit\nGEO_height = 35786e3  # Geostationary Orbit\nR_earth = 6371e3  # Earth radius\n\ndef plot_satellite_orbits():\n    fig, ax = plt.subplots(figsize=(10, 10))\n\n    # Plot Earth\n    earth_circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth')\n    ax.add_artist(earth_circle)\n\n    # Plot orbits\n    theta = np.linspace(0, 2*np.pi, 100)\n\n    # LEO\n    leo_radius = R_earth + LEO_height\n    ax.plot(leo_radius*np.cos(theta), leo_radius*np.sin(theta), 'r-', label='LEO')\n\n    # GEO\n    geo_radius = R_earth + GEO_height\n    ax.plot(geo_radius*np.cos(theta), geo_radius*np.sin(theta), 'g-', label='GEO')\n\n    ax.set_aspect('equal')\n    ax.grid(True)\n    ax.set_xlabel('Distance (m)')\n    ax.set_ylabel('Distance (m)')\n    ax.set_title('Common Satellite Orbits')\n    ax.legend()\n\n    # Set limits to show both orbits clearly\n    limit = GEO_height + R_earth\n    ax.set_xlim(-limit, limit)\n    ax.set_ylim(-limit, limit)\n\n    plt.show()\n\nplot_satellite_orbits()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-solar-system-analysis","title":"3.2 Solar System Analysis","text":"<p>The relationship extends to planetary orbits:</p> Planet Orbital Period (years) Semi-major Axis (AU) T\u00b2/r\u00b3 (constant) Mercury 0.24 0.39 1.00 Venus 0.62 0.72 1.00 Earth 1.00 1.00 1.00 Mars 1.88 1.52 1.00"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-limitations-and-extensions","title":"4. Limitations and Extensions","text":"<ol> <li>Elliptical Orbits: For non-circular orbits, r becomes the semi-major axis.</li> <li>Relativistic Effects: At high velocities or strong gravitational fields, corrections are needed.</li> <li>Multi-body Systems: Additional terms required for n-body problems.</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","title":"5. Conclusion","text":"<p>Kepler's Third Law provides a powerful tool for understanding orbital dynamics, from artificial satellites to planetary motion. The computational models demonstrate the precise mathematical relationships governing orbital motion and provide insights into the design of space missions and the study of celestial mechanics.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","title":"References","text":"<ol> <li>Classical Mechanics (Goldstein)</li> <li>Orbital Mechanics for Engineering Students (Curtis)</li> <li>Fundamentals of Astrodynamics (Bate, Mueller, White) </li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_2/","title":"Problem 2","text":"<p>Escape Velocities and Cosmic Velocities</p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-basic-principles-of-gravitational-escape","title":"1.1 Basic Principles of Gravitational Escape","text":"<p>The concept of escape velocity emerges from the principle of energy conservation. For an object to escape a celestial body's gravitational field, its kinetic energy must equal or exceed the gravitational potential energy:</p> \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\] <p>Where: - \\(m\\) is the mass of the escaping object - \\(v\\) is the velocity - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius from the center of the celestial body</p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-the-three-cosmic-velocities","title":"1.2 The Three Cosmic Velocities","text":"<ol> <li>First Cosmic Velocity (Orbital Velocity)</li> <li>For circular orbit: Gravitational force equals centripetal force    $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$</li> <li> <p>Solving for \\(v_1\\):    $$ v_1 = \\sqrt{\\frac{GM}{R}} $$</p> </li> <li> <p>Second Cosmic Velocity (Escape Velocity)</p> </li> <li> <p>From energy conservation:    $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}v_1 $$</p> </li> <li> <p>Third Cosmic Velocity (Solar System Escape Velocity)</p> </li> <li>Combines planetary escape velocity with solar escape velocity:    $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$    where \\(v_{sun}\\) is the orbital velocity around the Sun.</li> </ol> <p>Let's visualize these relationships with Python:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.constants import G\n\n# Set style\nplt.style.use('default')  # Using default style instead of seaborn\ncolors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']  # Custom color palette\n\ndef calculate_velocities(mass, radius, distance_from_sun=None):\n    \"\"\"Calculate cosmic velocities for a celestial body\"\"\"\n    v1 = np.sqrt(G * mass / radius)\n    v2 = np.sqrt(2) * v1\n\n    if distance_from_sun:\n        v_sun = np.sqrt(G * 1.989e30 / distance_from_sun)  # Sun's mass\n        v3 = np.sqrt(v2**2 + v_sun**2)\n        return v1, v2, v3\n    return v1, v2\n\n# Celestial body data (mass in kg, radius in m, distance from sun in m)\nbodies = {\n    \"Earth\": (5.972e24, 6.371e6, 1.496e11),\n    \"Mars\": (6.417e23, 3.389e6, 2.279e11),\n    \"Jupiter\": (1.898e27, 6.9911e7, 7.786e11),\n    \"Moon\": (7.34767309e22, 1.737e6, None),\n    \"Mercury\": (3.285e23, 2.439e6, 5.79e10)\n}\n\n# Calculate velocities\nvelocities = {body: calculate_velocities(mass, radius, dist) \n             for body, (mass, radius, dist) in bodies.items()}\n\n# Create visualization\nfig = plt.figure(figsize=(15, 10))\ngs = plt.GridSpec(2, 2)\n\n# Plot 1: Bar comparison\nax1 = fig.add_subplot(gs[0, :])\nbodies_list = list(bodies.keys())\nv1_vals = [v[0]/1000 for v in velocities.values()]  # Convert to km/s\nv2_vals = [v[1]/1000 for v in velocities.values()]\nv3_vals = [v[2]/1000 if len(v) &gt; 2 else 0 for v in velocities.values()]\n\nx = np.arange(len(bodies_list))\nwidth = 0.25\n\nbars1 = ax1.bar(x - width, v1_vals, width, label='First Cosmic Velocity', color=colors[0])\nbars2 = ax1.bar(x, v2_vals, width, label='Second Cosmic Velocity', color=colors[1])\nbars3 = ax1.bar(x + width, v3_vals, width, label='Third Cosmic Velocity', color=colors[2])\n\nax1.set_ylabel('Velocity (km/s)')\nax1.set_title('Comparison of Cosmic Velocities for Different Celestial Bodies')\nax1.set_xticks(x)\nax1.set_xticklabels(bodies_list)\nax1.legend()\nax1.grid(True, alpha=0.3)\n\n# Plot 2: Velocity vs Radius relationship\nax2 = fig.add_subplot(gs[1, 0])\nradii = np.linspace(1e6, 1e8, 1000)\nmasses = [1e24, 5e24, 1e25]\nfor i, mass in enumerate(masses):\n    v1 = np.sqrt(G * mass / radii)\n    ax2.plot(radii/1000, v1/1000, label=f'Mass = {mass:.1e} kg', color=colors[i])\n\nax2.set_xlabel('Radius (km)')\nax2.set_ylabel('First Cosmic Velocity (km/s)')\nax2.set_title('First Cosmic Velocity vs Radius')\nax2.legend()\nax2.set_xscale('log')\nax2.set_yscale('log')\nax2.grid(True, alpha=0.3)\n\n# Plot 3: Escape velocity field\nax3 = fig.add_subplot(gs[1, 1])\nx = np.linspace(-2, 2, 100)\ny = np.linspace(-2, 2, 100)\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nV = np.sqrt(2*G*5.972e24/(R*6.371e6))/1000  # Earth's escape velocity field\n\ncontour = ax3.contour(X, Y, V, levels=15, colors='black')\nax3.clabel(contour, inline=True, fontsize=8)\nax3.set_title('Earth Escape Velocity Field (km/s)')\nax3.set_xlabel('Distance (Earth Radii)')\nax3.set_ylabel('Distance (Earth Radii)')\nax3.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-analysis-of-results","title":"2. Analysis of Results","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-velocity-relationships","title":"2.1 Velocity Relationships","text":"<p>Let's examine how these velocities vary with distance from a celestial body:</p> <pre><code># Create distance-velocity relationship plot\nplt.figure(figsize=(10, 6))\ndistances = np.linspace(1, 10, 1000)  # In Earth radii\nearth_mass = 5.972e24\nearth_radius = 6.371e6\n\nv1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000\nv2 = np.sqrt(2) * v1\n\nplt.plot(distances, v1, label='First Cosmic Velocity')\nplt.plot(distances, v2, label='Second Cosmic Velocity')\nplt.xlabel('Distance (Earth Radii)')\nplt.ylabel('Velocity (km/s)')\nplt.title('Cosmic Velocities vs Distance from Earth')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-key-observations","title":"2.2 Key Observations","text":"<ol> <li>Inverse Square Relationship: Both first and second cosmic velocities decrease with the square root of distance.</li> <li>Mass Dependence: Larger celestial bodies require higher velocities for escape.</li> <li>Radius Effect: For a given mass, smaller bodies have higher surface escape velocities.</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-applications-in-space-exploration","title":"3. Applications in Space Exploration","text":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-launch-requirements","title":"3.1 Launch Requirements","text":"<p>Let's visualize the minimum energy requirements for different space missions:</p> <pre><code># Create mission energy requirements visualization\nmissions = {\n    'Low Earth Orbit': 7.8,\n    'Geostationary Orbit': 11.2,\n    'Moon Transfer': 11.2,\n    'Mars Transfer': 11.6,\n    'Solar System Escape': 16.6\n}\n\nplt.figure(figsize=(10, 6))\nplt.barh(list(missions.keys()), list(missions.values()))\nplt.xlabel('Minimum Velocity Required (km/s)')\nplt.title('Velocity Requirements for Space Missions')\nplt.grid(True)\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-practical-considerations","title":"3.2 Practical Considerations","text":"<ul> <li>Atmospheric Drag: Requires additional energy to overcome</li> <li>Gravitational Assists: Can reduce required velocities</li> <li>Orbital Mechanics: Optimal launch windows and trajectories</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-conclusion","title":"4. Conclusion","text":"<p>Understanding cosmic velocities is fundamental to space exploration. The relationships between these velocities help us: - Design efficient launch systems - Plan interplanetary missions - Calculate fuel requirements - Determine optimal trajectories</p> <p>The mathematical framework provided allows us to calculate precise requirements for any celestial body, making it an essential tool in modern space exploration.</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/","title":"Problem 3","text":"<p>Trajectories of a Freely Released Payload Near Earth</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","title":"Types of Possible Trajectories","text":"<p>The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are determined by comparing the payload's velocity to key orbital velocities:</p> <ol> <li> <p>First Cosmic Velocity (Circular Orbital Velocity):    $$ v_1 = \\sqrt{\\frac{GM}{r}} $$</p> </li> <li> <p>Second Cosmic Velocity (Escape Velocity):    $$ v_2 = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2}v_1 $$</p> </li> </ol> <p>where: - \\( G \\) is the gravitational constant - \\( M \\) is Earth's mass - \\( r \\) is the distance from Earth's center</p> <p>Let's visualize these velocities as a function of altitude:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Constants\nG = 6.67430e-11  # Gravitational constant (m^3/kg/s^2)\nM = 5.972e24     # Earth mass (kg)\nR = 6.371e6      # Earth radius (m)\n\n# Calculate velocities at different altitudes\naltitudes = np.linspace(0, 1000000, 1000)  # Altitudes from 0 to 1000 km\nr = R + altitudes\nv1 = np.sqrt(G * M / r)\nv2 = np.sqrt(2 * G * M / r)\n\nplt.figure(figsize=(10, 6))\nplt.plot(altitudes/1000, v1/1000, 'b-', label='Orbital Velocity (v\u2081)')\nplt.plot(altitudes/1000, v2/1000, 'r-', label='Escape Velocity (v\u2082)')\nplt.xlabel('Altitude (km)')\nplt.ylabel('Velocity (km/s)')\nplt.title('Orbital and Escape Velocities vs Altitude')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-classification","title":"Trajectory Classification","text":"<p>The payload's path depends on its velocity relative to these thresholds:</p> <ol> <li>Suborbital (v &lt; v\u2081):</li> <li>Follows a parabolic trajectory</li> <li>Returns to Earth</li> <li> <p>Energy equation: \\( E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} &lt; 0 \\)</p> </li> <li> <p>Circular Orbit (v = v\u2081):</p> </li> <li>Maintains constant altitude</li> <li> <p>Energy equation: \\( E = -\\frac{GMm}{2r} \\)</p> </li> <li> <p>Elliptical Orbit (v\u2081 &lt; v &lt; v\u2082):</p> </li> <li>Closed orbit with varying altitude</li> <li> <p>Energy equation: \\( -\\frac{GMm}{2r} &lt; E &lt; 0 \\)</p> </li> <li> <p>Parabolic Escape (v = v\u2082):</p> </li> <li>Escape trajectory with zero excess velocity</li> <li> <p>Energy equation: \\( E = 0 \\)</p> </li> <li> <p>Hyperbolic Escape (v &gt; v\u2082):</p> </li> <li>Escape trajectory with excess velocity</li> <li>Energy equation: \\( E &gt; 0 \\)</li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-analysis","title":"2. Mathematical Analysis","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","title":"Equations of Motion","text":"<p>The motion is governed by Newton's Second Law and Universal Gravitation:</p> \\[ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r} \\] <p>In Cartesian coordinates: $$ \\ddot{x} = -\\frac{GMx}{(x^2 + y^2)^{3/2}} $$ $$ \\ddot{y} = -\\frac{GMy}{(x^2 + y^2)^{3/2}} $$</p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conservation-laws","title":"Conservation Laws","text":"<ol> <li> <p>Angular Momentum:    $$ L = mr^2\\dot{\\theta} = \\text{constant} $$</p> </li> <li> <p>Energy:    $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} = \\text{constant} $$</p> </li> </ol>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computational-analysis","title":"3. Computational Analysis","text":"<p>Let's simulate different trajectory types:</p> <pre><code>import numpy as np\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\n\ndef equations(t, state):\n    x, vx, y, vy = state\n    r = np.sqrt(x**2 + y**2)\n    ax = -G * M * x / r**3\n    ay = -G * M * y / r**3\n    return [vx, ax, vy, ay]\n\ndef simulate_trajectory(v0, angle_deg, altitude=500000):\n    # Initial conditions\n    x0 = R + altitude\n    y0 = 0\n    angle_rad = np.radians(angle_deg)\n    vx0 = v0 * np.cos(angle_rad)\n    vy0 = v0 * np.sin(angle_rad)\n\n    # Time span\n    t_span = (0, 20000)\n    t_eval = np.linspace(0, 20000, 1000)\n\n    # Solve ODE\n    sol = solve_ivp(equations, t_span, [x0, vx0, y0, vy0], \n                    t_eval=t_eval, method='RK45')\n    return sol.y[0], sol.y[2]\n\n# Plot different trajectories\nplt.figure(figsize=(12, 12))\n\n# Calculate v1 at release altitude\naltitude = 500000\nr = R + altitude\nv1 = np.sqrt(G * M / r)\nv2 = np.sqrt(2 * G * M / r)\n\nvelocities = [0.8*v1, v1, 1.2*v1, v2, 1.2*v2]\nlabels = ['Suborbital', 'Circular', 'Elliptical', \n          'Parabolic', 'Hyperbolic']\nangles = [0, 0, 0, 0, 0]\n\n# Plot Earth\ntheta = np.linspace(0, 2*np.pi, 100)\nearth_x = R * np.cos(theta)\nearth_y = R * np.sin(theta)\nplt.plot(earth_x, earth_y, 'b-', label='Earth')\n\n# Plot trajectories\nfor v, label, angle in zip(velocities, labels, angles):\n    x, y = simulate_trajectory(v, angle)\n    plt.plot(x, y, label=f'{label} (v = {v/1000:.1f} km/s)')\n\nplt.axis('equal')\nplt.grid(True)\nplt.legend()\nplt.title('Different Types of Orbital Trajectories')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-energy-analysis","title":"4. Energy Analysis","text":"<p>Let's analyze the energy distribution for different trajectories:</p> <pre><code>def calculate_energy(x, y, vx, vy):\n    r = np.sqrt(x**2 + y**2)\n    v = np.sqrt(vx**2 + vy**2)\n    KE = 0.5 * v**2\n    PE = -G * M / r\n    return KE, PE, KE + PE\n\n# Plot energy evolution\nplt.figure(figsize=(12, 6))\n\n# Choose one trajectory (elliptical)\nv0 = 1.2 * v1\nt_span = (0, 20000)\nt_eval = np.linspace(0, 20000, 1000)\n\n# Solve ODE with same time points as t_eval\nsol = solve_ivp(equations, t_span, [R + altitude, v0, 0, 0], \n                t_eval=t_eval, method='RK45', rtol=1e-8, atol=1e-8)\n\n# Calculate energies\nKE, PE, E = calculate_energy(sol.y[0], sol.y[2], sol.y[1], sol.y[3])\n\n# Now plot using sol.t instead of t_eval to ensure matching dimensions\nplt.plot(sol.t, KE, 'r-', label='Kinetic Energy')\nplt.plot(sol.t, PE, 'b-', label='Potential Energy')\nplt.plot(sol.t, E, 'g-', label='Total Energy')\nplt.xlabel('Time (s)')\nplt.ylabel('Energy (J/kg)')\nplt.title('Energy Evolution in Elliptical Orbit')\nplt.grid(True)\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-practical-applications","title":"5. Practical Applications","text":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-satellite-deployment","title":"1. Satellite Deployment","text":"<ul> <li>Precise velocity control for desired orbit</li> <li>Minimizing orbital corrections</li> <li>Station-keeping requirements</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-reentry-scenarios","title":"2. Reentry Scenarios","text":"<ul> <li>Controlled deorbiting</li> <li>Heat shield requirements</li> <li>Landing point prediction</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-interplanetary-missions","title":"3. Interplanetary Missions","text":"<ul> <li>Escape trajectory design</li> <li>Gravity assist maneuvers</li> <li>Delta-v budgeting</li> </ul>"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-conclusion","title":"6. Conclusion","text":"<p>Understanding orbital trajectories is fundamental for: - Mission planning and execution - Risk assessment and mitigation - Optimal resource utilization - Safety of space operations</p> <p>The analysis demonstrates how initial conditions determine the final trajectory, emphasizing the importance of precise calculations in space missions.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/","title":"Problem 1","text":"<p>Interference Patterns on a Water Surface</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/3%20Waves/Problem_1/#11-single-wave-source","title":"1.1 Single Wave Source","text":"<p>A circular wave from a point source creates ripples that spread outward. The displacement \u03b7(x, y, t) at any point is given by:</p> \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] <p>where: - A: wave amplitude - r: distance from source = \\(\\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) - k: wave number = \\(\\frac{2\\pi}{\\lambda}\\) - \u03c9: angular frequency = 2\u03c0f - \u03c6: initial phase</p> <p>Let's first visualize a single wave source:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndef single_wave(X, Y, source, t=0, A=1, k=1, omega=2*np.pi):\n    x0, y0 = source\n    r = np.sqrt((X - x0)**2 + (Y - y0)**2)\n    return A/np.sqrt(r + 1e-6) * np.cos(k*r - omega*t)\n\n# Create grid\nx = np.linspace(-20, 20, 200)\ny = np.linspace(-20, 20, 200)\nX, Y = np.meshgrid(x, y)\n\n# Single source at origin\nsource = (0, 0)\nwave = single_wave(X, Y, source)\n\nplt.figure(figsize=(8, 6))\nplt.imshow(wave, extent=[-20, 20, -20, 20], cmap='coolwarm', origin='lower')\nplt.colorbar(label='Wave Amplitude')\nplt.scatter(*source, color='black', s=100, label='Wave Source')\nplt.title('Single Circular Wave Source')\nplt.xlabel('X Position')\nplt.ylabel('Y Position')\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#12-multiple-wave-sources","title":"1.2 Multiple Wave Sources","text":"<p>For N sources, the total displacement follows the superposition principle:</p> \\[ \\eta_{total}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(kr_i - \\omega t + \\phi_i) \\] <p>where \\(r_i\\) is the distance from the i-th source.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-implementation-for-regular-polygons","title":"2. Implementation for Regular Polygons","text":""},{"location":"1%20Physics/3%20Waves/Problem_1/#21-source-placement","title":"2.1 Source Placement","text":"<p>We'll place sources at vertices of regular polygons. For an N-sided polygon:</p> \\[ x_i = R\\cos(2\\pi i/N) $$ $$ y_i = R\\sin(2\\pi i/N) \\] <p>where R is the radius of the circumscribed circle.</p> <p>Let's create a function to generate and visualize interference patterns:</p> <pre><code>def create_polygon_sources(N, radius):\n    angles = np.linspace(0, 2*np.pi, N, endpoint=False)\n    return [(radius*np.cos(a), radius*np.sin(a)) for a in angles]\n\ndef plot_interference(N, radius=10, size=40, resolution=200):\n    # Setup grid\n    x = np.linspace(-size/2, size/2, resolution)\n    y = np.linspace(-size/2, size/2, resolution)\n    X, Y = np.meshgrid(x, y)\n\n    # Create sources\n    sources = create_polygon_sources(N, radius)\n\n    # Calculate interference\n    total_wave = np.zeros_like(X)\n    for source in sources:\n        total_wave += single_wave(X, Y, source)\n\n    # Plot\n    plt.figure(figsize=(10, 8))\n    plt.imshow(total_wave, extent=[-size/2, size/2, -size/2, size/2], \n               cmap='coolwarm', origin='lower')\n    plt.colorbar(label='Wave Amplitude')\n\n    # Plot sources\n    sources_x, sources_y = zip(*sources)\n    plt.scatter(sources_x, sources_y, color='black', s=100, \n               label=f'{N} Wave Sources')\n\n    plt.title(f'Interference Pattern for {N}-sided Regular Polygon')\n    plt.xlabel('X Position')\n    plt.ylabel('Y Position')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n# Visualize patterns for different polygons\nfor N in [3, 4, 5]:\n    plot_interference(N)\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-analysis-of-symmetry","title":"2.2 Analysis of Symmetry","text":"<p>Let's analyze how the interference pattern changes with time:</p> <pre><code>def animate_interference(N, frames=4):\n    fig, axes = plt.subplots(1, frames, figsize=(20, 5))\n    times = np.linspace(0, 2*np.pi, frames)\n\n    x = np.linspace(-20, 20, 200)\n    y = np.linspace(-20, 20, 200)\n    X, Y = np.meshgrid(x, y)\n    sources = create_polygon_sources(N, 10)\n\n    for i, t in enumerate(times):\n        total_wave = np.zeros_like(X)\n        for source in sources:\n            total_wave += single_wave(X, Y, source, t=t)\n\n        im = axes[i].imshow(total_wave, extent=[-20, 20, -20, 20], \n                           cmap='coolwarm', origin='lower')\n        axes[i].scatter(*zip(*sources), color='black', s=50)\n        axes[i].set_title(f't = {t:.1f}')\n        plt.colorbar(im, ax=axes[i])\n\n    plt.suptitle(f'Time Evolution of {N}-sided Polygon Interference Pattern')\n    plt.tight_layout()\n    plt.show()\n\nanimate_interference(4)\n</code></pre> <p></p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-analysis-of-results","title":"3. Analysis of Results","text":""},{"location":"1%20Physics/3%20Waves/Problem_1/#31-constructive-interference","title":"3.1 Constructive Interference","text":"<p>Constructive interference occurs when waves are in phase:</p> \\[ |r_1 - r_2| = n\\lambda \\] <p>where n is an integer and \u03bb is the wavelength.</p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#32-destructive-interference","title":"3.2 Destructive Interference","text":"<p>Destructive interference occurs when waves are out of phase:</p> \\[ |r_1 - r_2| = (n + \\frac{1}{2})\\lambda \\] <p>Let's visualize the interference intensity:</p> <pre><code>def plot_intensity(N, radius=10):\n    x = np.linspace(-20, 20, 200)\n    y = np.linspace(-20, 20, 200)\n    X, Y = np.meshgrid(x, y)\n    sources = create_polygon_sources(N, radius)\n\n    total_wave = np.zeros_like(X)\n    for source in sources:\n        total_wave += single_wave(X, Y, source)\n\n    intensity = total_wave**2\n\n    plt.figure(figsize=(10, 8))\n    plt.imshow(intensity, extent=[-20, 20, -20, 20], \n               cmap='viridis', origin='lower')\n    plt.colorbar(label='Intensity')\n    plt.scatter(*zip(*sources), color='white', s=100)\n    plt.title(f'Wave Intensity Pattern ({N}-sided Polygon)')\n    plt.xlabel('X Position')\n    plt.ylabel('Y Position')\n    plt.show()\n\nplot_intensity(4)\n</code></pre> <p></p>"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-conclusions","title":"4. Conclusions","text":"<ol> <li>Symmetry: The interference pattern reflects the symmetry of the source polygon.</li> <li>Nodal Lines: Clear lines of destructive interference form geometric patterns.</li> <li>Central Maxima: Strong constructive interference occurs at the center due to equal path lengths.</li> </ol>"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-applications","title":"5. Applications","text":"<ul> <li>Acoustic design in concert halls</li> <li>Antenna array design</li> <li>Optical interferometry</li> <li>Water wave energy focusing</li> </ul> <p>The study of interference patterns helps us understand wave behavior in various fields, from acoustics to electromagnetic theory.</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","title":"Problem 1","text":"<p>Investigating Charged Particle Motion under Electromagnetic Fields</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#governing-equations","title":"Governing Equations","text":"<p>The motion of charged particles in electromagnetic fields is governed by the Lorentz force:</p> \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] <p>Using Newton's second law:</p> \\[ m\\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] <p>In component form for 3D motion:</p> \\[ m\\frac{dv_x}{dt} = qE_x + q(v_yB_z - v_zB_y) $$ $$ m\\frac{dv_y}{dt} = qE_y + q(v_zB_x - v_xB_z) $$ $$ m\\frac{dv_z}{dt} = qE_z + q(v_xB_y - v_yB_x) \\]"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-parameters","title":"Key Parameters","text":"<ol> <li> <p>Cyclotron Frequency: $$ \\omega_c = \\frac{qB}{m} $$</p> </li> <li> <p>Larmor Radius: $$ r_L = \\frac{mv_\\perp}{qB} $$</p> </li> <li> <p>E\u00d7B Drift Velocity: $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$</p> </li> </ol> <p>Let's simulate these motions using Python:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy.integrate import odeint\n\ndef lorentz_force(state, t, q, m, E, B):\n    x, y, z, vx, vy, vz = state\n\n    # Force components\n    dvx_dt = (q/m) * (E[0] + vy*B[2] - vz*B[1])\n    dvy_dt = (q/m) * (E[1] + vz*B[0] - vx*B[2])\n    dvz_dt = (q/m) * (E[2] + vx*B[1] - vy*B[0])\n\n    return [vx, vy, vz, dvx_dt, dvy_dt, dvz_dt]\n\n# Parameters\nq = 1.6e-19  # electron charge\nm = 9.1e-31  # electron mass\nt = np.linspace(0, 1e-9, 1000)\n\n# Case 1: Uniform Magnetic Field\nB = [0, 0, 1.0]  # Tesla\nE = [0, 0, 0]    # V/m\ninitial_state = [0, 0, 0, 1e6, 1e6, 0]  # Initial position and velocity\n\nsolution = odeint(lorentz_force, initial_state, t, args=(q, m, E, B))\n\n# Plot trajectory\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(111, projection='3d')\nax.plot(solution[:, 0], solution[:, 1], solution[:, 2])\nax.set_xlabel('X (m)')\nax.set_ylabel('Y (m)')\nax.set_zlabel('Z (m)')\nax.set_title('Particle Motion in Uniform Magnetic Field')\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#analysis-of-different-field-configurations","title":"Analysis of Different Field Configurations","text":"<p>Let's examine the E\u00d7B drift:</p> <pre><code># Case 2: Crossed E and B fields\nE = [1e5, 0, 0]  # V/m\nB = [0, 0, 1.0]  # Tesla\ninitial_state = [0, 0, 0, 0, 1e6, 0]\n\nsolution_ExB = odeint(lorentz_force, initial_state, t, args=(q, m, E, B))\n\n# Plot E\u00d7B drift\nplt.figure(figsize=(12, 5))\nplt.subplot(121)\nplt.plot(solution_ExB[:, 0], solution_ExB[:, 1])\nplt.xlabel('X (m)')\nplt.ylabel('Y (m)')\nplt.title('E\u00d7B Drift Trajectory')\nplt.grid(True)\n\n# Plot velocity components\nplt.subplot(122)\nplt.plot(t, solution_ExB[:, 3], label='vx')\nplt.plot(t, solution_ExB[:, 4], label='vy')\nplt.xlabel('Time (s)')\nplt.ylabel('Velocity (m/s)')\nplt.title('Velocity Components')\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-parameter-study","title":"2. Parameter Study","text":"<p>Let's investigate how the Larmor radius changes with magnetic field strength:</p> <pre><code>def larmor_radius(v_perp, B, q, m):\n    return m * v_perp / (q * B)\n\nB_values = np.linspace(0.1, 2.0, 100)\nv_perp = 1e6\nradii = [larmor_radius(v_perp, B, q, m) for B in B_values]\n\nplt.figure(figsize=(10, 6))\nplt.plot(B_values, radii)\nplt.xlabel('Magnetic Field Strength (T)')\nplt.ylabel('Larmor Radius (m)')\nplt.title('Larmor Radius vs Magnetic Field Strength')\nplt.grid(True)\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-applications","title":"3. Applications","text":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-operation","title":"Cyclotron Operation","text":"<p>The cyclotron frequency determines particle acceleration:</p> <pre><code>def cyclotron_freq(B, q, m):\n    return q * B / m\n\nB_range = np.linspace(0.1, 3.0, 100)\nfrequencies = [cyclotron_freq(B, q, m) for B in B_range]\n\nplt.figure(figsize=(10, 6))\nplt.plot(B_range, np.array(frequencies)/1e9)  # Convert to GHz\nplt.xlabel('Magnetic Field (T)')\nplt.ylabel('Cyclotron Frequency (GHz)')\nplt.title('Cyclotron Frequency vs Magnetic Field')\nplt.grid(True)\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-advanced-analysis-non-uniform-fields","title":"4. Advanced Analysis: Non-uniform Fields","text":"<p>For non-uniform magnetic fields, we can model magnetic mirrors:</p> <pre><code>def magnetic_mirror(state, t, q, m):\n    x, y, z, vx, vy, vz = state\n    B = [0, 0, 1.0 + 0.1*z**2]  # Non-uniform B field\n    E = [0, 0, 0]\n\n    return lorentz_force(state, t, q, m, E, B)\n\ninitial_state = [0, 0, 0, 1e5, 1e5, 1e5]\nsolution_mirror = odeint(magnetic_mirror, initial_state, t, args=(q, m))\n\nfig = plt.figure(figsize=(12, 6))\nax = fig.add_subplot(111, projection='3d')\nax.plot(solution_mirror[:, 0], solution_mirror[:, 1], solution_mirror[:, 2])\nax.set_xlabel('X (m)')\nax.set_ylabel('Y (m)')\nax.set_zlabel('Z (m)')\nax.set_title('Particle Motion in Magnetic Mirror')\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-practical-applications","title":"5. Practical Applications","text":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","title":"Particle Accelerators","text":"<ul> <li>Cyclotrons</li> <li>Synchrotrons </li> <li>Linear accelerators</li> </ul>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","title":"Plasma Confinement","text":"<ul> <li>Tokamaks</li> <li>Magnetic mirrors</li> <li>Stellarators</li> </ul>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scientific-instruments","title":"Scientific Instruments","text":"<ul> <li>Mass spectrometers</li> <li>Electron microscopes</li> <li>Beta-ray spectrometers</li> </ul>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","title":"Conclusion","text":"<p>The Lorentz force provides a fundamental mechanism for controlling charged particle motion. Through simulation, we've demonstrated various configurations and their applications in modern physics and technology. The interplay between electric and magnetic fields offers rich possibilities for particle manipulation and confinement.</p>"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#future-extensions","title":"Future Extensions","text":"<ol> <li>Include relativistic effects for high-speed particles</li> <li>Add collision effects and particle interactions</li> <li>Simulate more complex field geometries</li> <li>Include quantum effects for very low energies</li> </ol>"},{"location":"1%20Physics/5%20Circuits/Problem_1/","title":"Problem 1","text":"<p>Equivalent Resistance Using Graph Theory</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-basic-circuit-laws","title":"1.1 Basic Circuit Laws","text":"<p>For resistors in series and parallel, the equivalent resistance is given by:</p> <p>Series: $$ R_{eq} = \\sum_{i=1}^n R_i $$</p> <p>Parallel: $$ \\frac{1}{R_{eq}} = \\sum_{i=1}^n \\frac{1}{R_i} $$</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#12-graph-representation","title":"1.2 Graph Representation","text":"<p>A circuit can be represented as a weighted undirected graph G(V,E) where: - V: vertices (nodes) represent junctions - E: edges represent resistors - Weights: resistance values</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\ndef create_example_circuit():\n    G = nx.Graph()\n    # Add edges with resistance values\n    edges = [(0,1,2), (1,2,4), (2,3,1), (0,2,3), (1,3,5)]\n    G.add_weighted_edges_from(edges)\n    return G\n\ndef plot_circuit(G, title=\"Circuit Graph\"):\n    plt.figure(figsize=(10, 8))\n    pos = nx.spring_layout(G)\n\n    # Draw edges with weights\n    nx.draw_networkx_edges(G, pos, width=2)\n    nx.draw_networkx_nodes(G, pos, node_color='lightblue', \n                          node_size=500)\n    nx.draw_networkx_labels(G, pos)\n\n    # Add edge labels (resistance values)\n    edge_labels = nx.get_edge_attributes(G, 'weight')\n    nx.draw_networkx_edge_labels(G, pos, edge_labels)\n\n    plt.title(title)\n    plt.axis('off')\n    plt.show()\n\n# Create and plot example circuit\nG = create_example_circuit()\nplot_circuit(G)\n</code></pre> <p></p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-implementation","title":"2. Algorithm Implementation","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-series-reduction","title":"2.1 Series Reduction","text":"<p>For series reduction, we identify nodes with exactly two connections:</p> <pre><code>def find_series_nodes(G):\n    return [node for node in G.nodes() \n            if G.degree(node) == 2]\n\ndef reduce_series(G, node):\n    neighbors = list(G.neighbors(node))\n    r1 = G[node][neighbors[0]]['weight']\n    r2 = G[node][neighbors[1]]['weight']\n\n    # Add new combined resistance\n    G.add_edge(neighbors[0], neighbors[1], \n               weight=r1 + r2)\n    G.remove_node(node)\n    return G\n\n# Demonstrate series reduction\nG_series = create_example_circuit()\nplot_circuit(G_series, \"Before Series Reduction\")\n\nnode = find_series_nodes(G_series)[0]\nG_series = reduce_series(G_series, node)\nplot_circuit(G_series, \"After Series Reduction\")\n</code></pre> <p></p> <p></p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-parallel-reduction","title":"2.2 Parallel Reduction","text":"<p>For parallel resistors between the same nodes:</p> <pre><code>def reduce_parallel(G):\n    for u in G.nodes():\n        for v in G.nodes():\n            if u &lt; v and G.has_edge(u, v):\n                # Find parallel edges\n                paths = list(nx.edge_disjoint_paths(G, u, v))\n                if len(paths) &gt; 1:\n                    # Calculate equivalent resistance\n                    r_eq = 0\n                    for path in paths:\n                        r_path = sum(1/G[path[i]][path[i+1]]['weight'] \n                                   for i in range(len(path)-1))\n                        r_eq += r_path\n                    r_eq = 1/r_eq\n\n                    # Remove old edges and add new equivalent\n                    for path in paths:\n                        for i in range(len(path)-1):\n                            G.remove_edge(path[i], path[i+1])\n                    G.add_edge(u, v, weight=r_eq)\n    return G\n\n# Demonstrate parallel reduction\nG_parallel = nx.Graph()\nG_parallel.add_weighted_edges_from([(0,1,2), (0,1,3)])\nplot_circuit(G_parallel, \"Before Parallel Reduction\")\n\nG_parallel = reduce_parallel(G_parallel)\nplot_circuit(G_parallel, \"After Parallel Reduction\")\n</code></pre> <p> </p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-complete-algorithm","title":"3. Complete Algorithm","text":"<pre><code>def calculate_equivalent_resistance(G):\n    while len(G.nodes()) &gt; 2:\n        # Try series reduction first\n        series_nodes = find_series_nodes(G)\n        if series_nodes:\n            G = reduce_series(G, series_nodes[0])\n            continue\n\n        # Then try parallel reduction\n        G_before = G.copy()\n        G = reduce_parallel(G)\n        if nx.is_isomorphic(G, G_before):\n            break\n\n    if len(G.nodes()) == 2:\n        nodes = list(G.nodes())\n        return G[nodes[0]][nodes[1]]['weight']\n    return None\n\n# Test with example circuits\ndef test_circuit(edges, title=\"Test Circuit\"):\n    G = nx.Graph()\n    G.add_weighted_edges_from(edges)\n    plot_circuit(G, f\"{title} - Initial\")\n\n    R_eq = calculate_equivalent_resistance(G)\n    print(f\"Equivalent Resistance: {R_eq:.2f} \u03a9\")\n    plot_circuit(G, f\"{title} - Final\")\n    return R_eq\n\n# Example 1: Simple series-parallel\ntest_circuit([(0,1,2), (1,2,3), (0,2,6)], \n            \"Series-Parallel Circuit\")\n</code></pre> <p>Equivalent Resistance: 8.00 \u03a9 </p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-analysis-and-complexity","title":"4. Analysis and Complexity","text":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#41-time-complexity","title":"4.1 Time Complexity","text":"<ul> <li>Series reduction: O(V) for finding nodes, O(1) for reduction</li> <li>Parallel reduction: O(V\u00b2) for checking all node pairs</li> <li>Overall: O(V\u00b3) in worst case</li> </ul>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#42-space-complexity","title":"4.2 Space Complexity","text":"<ul> <li>O(V + E) for graph storage</li> <li>O(V) additional space for algorithm operations</li> </ul>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-applications-and-extensions","title":"5. Applications and Extensions","text":"<p>The graph-based circuit analysis approach has several key applications and potential extensions:</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#51-circuit-analysis-software","title":"5.1 Circuit Analysis Software","text":"<p>The algorithm can be integrated into: - Automated circuit simplification tools - Quick resistance calculation modules - Real-time analysis systems - Component parameter optimization software</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#52-network-optimization","title":"5.2 Network Optimization","text":"<p>The methods extend naturally to: - Power grid analysis and modeling - Circuit design optimization - Load balancing calculations  - Network reliability assessment</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#53-educational-tools","title":"5.3 Educational Tools","text":"<p>The visual nature makes it ideal for: - Interactive circuit visualization - Step-by-step reduction demonstrations - Virtual circuit building exercises - Learning progress tracking systems</p> <p>The graph theory approach provides a robust foundation for these applications while maintaining mathematical rigor and computational efficiency.</p>"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-conclusions","title":"6. Conclusions","text":"<p>The graph theory approach provides: 1. Systematic method for circuit analysis 2. Clear visualization of reduction steps 3. Extensible framework for complex circuits</p> <p>Future improvements could include: - Voltage and current calculations - Support for active components - Optimization for specific circuit types</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/","title":"Problem 1","text":"<p>Exploring the Central Limit Theorem through Simulations</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-theoretical-foundation","title":"1. Theoretical Foundation","text":"<p>The Central Limit Theorem (CLT) is a fundamental principle in statistics that states: for independent and identically distributed random variables, the distribution of their sample means approaches a normal distribution as the sample size increases, regardless of the underlying distribution.</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#mathematical-expression","title":"Mathematical Expression","text":"<p>For a population with mean \u03bc and variance \u03c3\u00b2, if we take samples of size n:</p> \\[ \\bar{X}_n \\sim N(\\mu, \\frac{\\sigma^2}{n}) \\] <p>where \\(\\bar{X}_n\\) is the sample mean distribution.</p> <p>The standardized form of the sampling distribution follows:</p> \\[ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\sim N(0,1) \\]"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-implementation-and-analysis","title":"2. Implementation and Analysis","text":"<p>Let's explore this through Python simulations with different distributions:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# For Colab, we need to use this to display plots\n%matplotlib inline\n\n# Plotting style configuration\nsns.set_style(\"whitegrid\")  # This is more reliable than plt.style.use('seaborn')\nplt.rcParams['figure.figsize'] = (12, 8)\n\ndef plot_sampling_distribution(population, sample_sizes, n_samples=1000, title=\"\"):\n    fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n    fig.suptitle(f'Sampling Distributions: {title}', fontsize=16)\n\n    for i, n in enumerate(sample_sizes):\n        row = i // 2\n        col = i % 2\n\n        # Generate sample means\n        sample_means = [np.mean(np.random.choice(population, size=n)) \n                       for _ in range(n_samples)]\n\n        # Plot histogram with KDE\n        sns.histplot(sample_means, kde=True, ax=axes[row, col])\n\n        # Add normal distribution fit\n        mu = np.mean(sample_means)\n        sigma = np.std(sample_means)\n        x = np.linspace(min(sample_means), max(sample_means), 100)\n        normal_dist = stats.norm.pdf(x, mu, sigma)\n        axes[row, col].plot(x, normal_dist * len(sample_means) * \n                          (max(sample_means) - min(sample_means)) / 30,\n                          'r--', lw=2, label='Normal Fit')\n\n        # Add theoretical values\n        axes[row, col].axvline(np.mean(population), color='g', \n                              linestyle='--', label='Population Mean')\n\n        axes[row, col].set_title(f'Sample Size = {n}\\n\u03bc={mu:.2f}, \u03c3={sigma:.2f}')\n        axes[row, col].set_xlabel('Sample Mean')\n        axes[row, col].set_ylabel('Frequency')\n        axes[row, col].legend()\n\n    plt.tight_layout()\n    return fig\n\n# 1. Uniform Distribution\nuniform_pop = np.random.uniform(0, 10, 10000)\nfig1 = plot_sampling_distribution(uniform_pop, [5, 10, 30, 50], \n                                title=\"Uniform Distribution (0, 10)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#21-uniform-distribution-analysis","title":"2.1 Uniform Distribution Analysis","text":"<p>The uniform distribution has a theoretical mean of: $$ \\mu = \\frac{a + b}{2} $$ and variance: $$ \\sigma^2 = \\frac{(b-a)^2}{12} $$</p> <p>For our case (0,10): - \u03bc = 5 - \u03c3\u00b2 \u2248 8.33</p> <pre><code># 2. Exponential Distribution\nexponential_pop = np.random.exponential(2, 10000)\nfig2 = plot_sampling_distribution(exponential_pop, [5, 10, 30, 50], \n                                title=\"Exponential Distribution (\u03bb=0.5)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#22-exponential-distribution-analysis","title":"2.2 Exponential Distribution Analysis","text":"<p>For exponential distribution with rate parameter \u03bb: $$ \\mu = \\frac{1}{\\lambda} $$ $$ \\sigma^2 = \\frac{1}{\\lambda^2} $$</p> <pre><code># 3. Binomial Distribution\nbinomial_pop = np.random.binomial(20, 0.3, 10000)\nfig3 = plot_sampling_distribution(binomial_pop, [5, 10, 30, 50], \n                                title=\"Binomial Distribution (n=20, p=0.3)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#23-binomial-distribution-analysis","title":"2.3 Binomial Distribution Analysis","text":"<p>For binomial distribution with parameters n and p: $$ \\mu = np $$ $$ \\sigma^2 = np(1-p) $$</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-convergence-analysis","title":"3. Convergence Analysis","text":"<p>Let's analyze the rate of convergence using Q-Q plots:</p> <pre><code>def plot_qq_analysis(population, sample_sizes, n_samples=1000):\n    fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n    fig.suptitle('Q-Q Plots for Different Sample Sizes', fontsize=16)\n\n    for i, n in enumerate(sample_sizes):\n        row = i // 2\n        col = i % 2\n\n        sample_means = [np.mean(np.random.choice(population, size=n)) \n                       for _ in range(n_samples)]\n\n        stats.probplot(sample_means, dist=\"norm\", plot=axes[row, col])\n        axes[row, col].set_title(f'Sample Size = {n}')\n\n    plt.tight_layout()\n    return fig\n\n# Analyze convergence for exponential distribution\nfig4 = plot_qq_analysis(exponential_pop, [5, 10, 30, 50])\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-standard-error-analysis","title":"4. Standard Error Analysis","text":"<p>The CLT predicts that the standard error (SE) of the sampling distribution decreases with the square root of the sample size:</p> \\[ SE = \\frac{\\sigma}{\\sqrt{n}} \\] <pre><code>def plot_standard_error(population, max_sample_size=100):\n    sample_sizes = np.arange(5, max_sample_size + 1, 5)\n    theoretical_se = np.std(population) / np.sqrt(sample_sizes)\n    empirical_se = []\n\n    for n in sample_sizes:\n        sample_means = [np.mean(np.random.choice(population, size=n)) \n                       for _ in range(1000)]\n        empirical_se.append(np.std(sample_means))\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(sample_sizes, theoretical_se, 'r-', label='Theoretical SE')\n    plt.plot(sample_sizes, empirical_se, 'b--', label='Empirical SE')\n    plt.xlabel('Sample Size')\n    plt.ylabel('Standard Error')\n    plt.title('Standard Error vs Sample Size')\n    plt.legend()\n    plt.grid(True)\n    return plt.gcf()\n\nfig5 = plot_standard_error(exponential_pop)\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-practical-applications","title":"5. Practical Applications","text":"<p>The CLT has numerous real-world applications:</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quality-control","title":"Quality Control","text":"<ul> <li>Monitoring manufacturing processes</li> <li>Establishing confidence intervals for measurements</li> </ul>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#financial-analysis","title":"Financial Analysis","text":"<ul> <li>Portfolio risk assessment</li> <li>Market return predictions</li> </ul>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#scientific-research","title":"Scientific Research","text":"<ul> <li>Experimental design</li> <li>Statistical inference</li> </ul>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-conclusions","title":"6. Conclusions","text":"<p>Our simulations demonstrate several key aspects of the CLT:</p> <ol> <li>The sampling distribution becomes more normal as sample size increases</li> <li>The convergence rate depends on the original distribution</li> <li>The standard error decreases predictably with sample size</li> <li>The theorem holds regardless of the population distribution</li> </ol> <p>These findings have important implications for statistical inference and experimental design in real-world applications.</p>"},{"location":"1%20Physics/6%20Statistics/Problem_1/#references","title":"References","text":"<ol> <li>Rice, J. A. (2006). Mathematical Statistics and Data Analysis</li> <li>Wasserman, L. (2004). All of Statistics</li> <li>Montgomery, D. C. (2009). Statistical Quality Control</li> </ol>"},{"location":"1%20Physics/6%20Statistics/Problem_2/","title":"Problem 2","text":"<p>Estimating \u03c0 using Monte Carlo Methods</p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-circle-based-monte-carlo-method","title":"1. Circle-Based Monte Carlo Method","text":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#11-theoretical-foundation","title":"1.1 Theoretical Foundation","text":"<p>The circle-based Monte Carlo method for estimating \u03c0 relies on the relationship between the area of a circle and its circumscribed square. For a unit circle (radius = 1) centered at the origin:</p> <ul> <li>Circle area: \\(A_c = \\pi r^2 = \\pi\\)</li> <li>Square area: \\(A_s = (2r)^2 = 4\\)</li> </ul> <p>The ratio of these areas is:</p> \\[ \\frac{A_c}{A_s} = \\frac{\\pi}{4} \\] <p>Therefore:</p> \\[ \\pi = 4 \\cdot \\frac{A_c}{A_s} \\approx 4 \\cdot \\frac{\\text{points inside circle}}{\\text{total points}} \\] <p>Let's implement this in Python:</p> <pre><code># Basic imports - no external dependencies\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\ndef estimate_pi_circle(n_points):\n    \"\"\"\n    Estimate \u03c0 using the circle method.\n    \"\"\"\n    # Generate random points\n    x = np.random.uniform(-1, 1, n_points)\n    y = np.random.uniform(-1, 1, n_points)\n\n    # Calculate distances from origin\n    distances = np.sqrt(x**2 + y**2)\n\n    # Count points inside circle\n    inside_circle = np.sum(distances &lt;= 1)\n\n    # Estimate pi\n    pi_estimate = 4 * inside_circle / n_points\n\n    return pi_estimate, x, y, distances\n\ndef plot_circle_method():\n    \"\"\"\n    Create visualization for the circle method with different sample sizes.\n    \"\"\"\n    sample_sizes = [100, 1000, 10000]\n    fig, axes = plt.subplots(1, 3, figsize=(20, 6))\n\n    for i, n in enumerate(sample_sizes):\n        pi_est, x, y, distances = estimate_pi_circle(n)\n\n        # Plot points\n        inside = distances &lt;= 1\n        axes[i].scatter(x[inside], y[inside], c='blue', alpha=0.6, label='Inside')\n        axes[i].scatter(x[~inside], y[~inside], c='red', alpha=0.6, label='Outside')\n\n        # Draw circle\n        theta = np.linspace(0, 2*np.pi, 100)\n        axes[i].plot(np.cos(theta), np.sin(theta), 'k-')\n\n        axes[i].set_aspect('equal')\n        axes[i].grid(True)\n        axes[i].set_title(f'n = {n}\\n\u03c0 \u2248 {pi_est:.6f}')\n        axes[i].legend()\n        axes[i].set_xlabel('x')\n        axes[i].set_ylabel('y')\n\n    plt.tight_layout()\n    plt.show()\n\ndef simulate_buffon_needle(n_needles, L=1, D=2):\n    \"\"\"\n    Simulate Buffon's needle experiment.\n    \"\"\"\n    # Random positions and angles\n    y = np.random.uniform(0, D, n_needles)\n    theta = np.random.uniform(0, np.pi, n_needles)\n\n    # Calculate needle endpoints\n    y2 = y + L * np.sin(theta)\n\n    # Count crossings\n    crossings = np.sum(np.floor(y/D) != np.floor(y2/D))\n\n    # Estimate pi\n    pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings &gt; 0 else np.inf\n\n    return pi_estimate, y, theta\n\ndef plot_buffon_needles(n_needles=50):\n    \"\"\"\n    Visualize Buffon's needle experiment.\n    \"\"\"\n    L, D = 1, 2\n    pi_est, y, theta = simulate_buffon_needle(n_needles, L, D)\n\n    # Calculate needle endpoints\n    x = np.zeros(n_needles)\n    y1 = y\n    x2 = L * np.cos(theta)\n    y2 = y + L * np.sin(theta)\n\n    plt.figure(figsize=(15, 8))\n\n    # Draw parallel lines\n    for i in range(-1, 4):\n        plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3)\n\n    # Draw needles\n    for i in range(n_needles):\n        crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D)\n        color = 'red' if crosses else 'blue'\n        plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6,\n                label='Crossing' if crosses and i == 0 else 'Not crossing' if not crosses and i == 0 else \"\")\n\n    plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.axis('equal')\n    plt.grid(True)\n    plt.legend()\n    plt.show()\n\ndef compare_methods(max_points=5, steps=50):\n    \"\"\"\n    Compare convergence of both methods.\n    \"\"\"\n    points = np.logspace(2, max_points, steps, dtype=int)\n    circle_errors = []\n    buffon_errors = []\n\n    for n in points:\n        # Circle method\n        pi_est_circle, _, _, _ = estimate_pi_circle(n)\n        circle_errors.append(abs(pi_est_circle - np.pi))\n\n        # Buffon's needle method\n        pi_est_buffon, _, _ = simulate_buffon_needle(n)\n        if pi_est_buffon != np.inf:\n            buffon_errors.append(abs(pi_est_buffon - np.pi))\n        else:\n            buffon_errors.append(np.nan)\n\n    plt.figure(figsize=(12, 8))\n    plt.loglog(points, circle_errors, 'b-', label='Circle Method')\n    plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle')\n    plt.grid(True)\n    plt.xlabel('Number of Points/Needles')\n    plt.ylabel('Absolute Error')\n    plt.title('Comparison of Method Convergence')\n    plt.legend()\n    plt.show()\n\n# Run all simulations\nprint(\"Starting Monte Carlo \u03c0 estimation...\")\n\nprint(\"\\nCircle Method Visualization:\")\nplot_circle_method()\n\nprint(\"\\nBuffon's Needle Visualization:\")\nplot_buffon_needles()\n\nprint(\"\\nMethod Comparison:\")\ncompare_methods()\n\nprint(\"\\nAll simulations completed!\")\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#12-convergence-analysis","title":"1.2 Convergence Analysis","text":"<p>Let's analyze how the estimate converges as we increase the number of points:</p> <pre><code>def convergence_analysis(max_points, steps):\n    points = np.logspace(2, max_points, steps, dtype=int)\n    estimates = []\n    errors = []\n\n    for n in points:\n        pi_est, _, _, _ = estimate_pi_circle(n)\n        estimates.append(pi_est)\n        errors.append(abs(pi_est - np.pi))\n\n    return points, estimates, errors\n\n# Perform analysis\npoints, estimates, errors = convergence_analysis(5, 50)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n\n# Estimates plot\nax1.semilogx(points, estimates, 'b-', label='Estimate')\nax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0')\nax1.grid(True)\nax1.set_xlabel('Number of Points')\nax1.set_ylabel('\u03c0 Estimate')\nax1.legend()\nax1.set_title('Convergence of \u03c0 Estimate')\n\n# Error plot\nax2.loglog(points, errors, 'g-')\nax2.grid(True)\nax2.set_xlabel('Number of Points')\nax2.set_ylabel('Absolute Error')\nax2.set_title('Error vs. Number of Points')\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-buffons-needle-method","title":"2. Buffon's Needle Method","text":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#21-theoretical-foundation","title":"2.1 Theoretical Foundation","text":"<p>Buffon's Needle problem involves dropping needles of length L onto a plane with parallel lines spaced distance D apart. The probability of a needle crossing a line is:</p> \\[ P(\\text{crossing}) = \\frac{2L}{\u03c0D} \\] <p>Therefore:</p> \\[ \u03c0 = \\frac{2L}{D} \\cdot \\frac{\\text{total drops}}{\\text{crossings}} \\] <p>Let's implement this method:</p> <pre><code>def simulate_buffon_needle(n_needles, L=1, D=2):\n    # Random positions and angles\n    y = np.random.uniform(0, D, n_needles)\n    theta = np.random.uniform(0, np.pi, n_needles)\n\n    # Calculate needle endpoints\n    y2 = y + L * np.sin(theta)\n\n    # Count crossings\n    crossings = np.sum(np.floor(y/D) != np.floor(y2/D))\n\n    # Estimate pi\n    pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings &gt; 0 else np.inf\n\n    return pi_estimate, y, theta\n\ndef plot_buffon_needles(n_needles=50):\n    L, D = 1, 2\n    pi_est, y, theta = simulate_buffon_needle(n_needles, L, D)\n\n    # Calculate needle endpoints\n    x = np.zeros(n_needles)\n    y1 = y\n    x2 = L * np.cos(theta)\n    y2 = y + L * np.sin(theta)\n\n    # Plot\n    plt.figure(figsize=(12, 6))\n\n    # Draw parallel lines\n    for i in range(-1, 4):\n        plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3)\n\n    # Draw needles\n    for i in range(n_needles):\n        crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D)\n        color = 'red' if crosses else 'blue'\n        plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6)\n\n    plt.title(f'Buffon\\'s Needle Simulation (n={n_needles}, \u03c0 \u2248 {pi_est:.6f})')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.axis('equal')\n    plt.grid(True)\n    plt.show()\n\n# Visualize Buffon's needle simulation\nplot_buffon_needles(50)\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#22-convergence-analysis-for-buffons-needle","title":"2.2 Convergence Analysis for Buffon's Needle","text":"<p>Let's analyze the convergence of the Buffon's needle method:</p> <pre><code>def buffon_convergence_analysis(max_points, steps):\n    points = np.logspace(2, max_points, steps, dtype=int)\n    estimates = []\n    errors = []\n\n    for n in points:\n        pi_est, _, _ = simulate_buffon_needle(n)\n        if pi_est != np.inf:\n            estimates.append(pi_est)\n            errors.append(abs(pi_est - np.pi))\n        else:\n            estimates.append(np.nan)\n            errors.append(np.nan)\n\n    return points, estimates, errors\n\n# Perform analysis\npoints, estimates, errors = buffon_convergence_analysis(5, 50)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n\n# Estimates plot\nax1.semilogx(points, estimates, 'b-', label='Estimate')\nax1.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0')\nax1.grid(True)\nax1.set_xlabel('Number of Needles')\nax1.set_ylabel('\u03c0 Estimate')\nax1.legend()\nax1.set_title('Convergence of Buffon\\'s Needle Method')\n\n# Error plot\nax2.loglog(points, errors, 'g-')\nax2.grid(True)\nax2.set_xlabel('Number of Needles')\nax2.set_ylabel('Absolute Error')\nax2.set_title('Error vs. Number of Needles')\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-comparison-of-methods","title":"3. Comparison of Methods","text":"<p>Let's compare the convergence rates of both methods:</p> <pre><code>def compare_methods(max_points=5, steps=50):\n    points = np.logspace(2, max_points, steps, dtype=int)\n    circle_errors = []\n    buffon_errors = []\n\n    for n in points:\n        # Circle method\n        pi_est_circle, _, _, _ = estimate_pi_circle(n)\n        circle_errors.append(abs(pi_est_circle - np.pi))\n\n        # Buffon's needle method\n        pi_est_buffon, _, _ = simulate_buffon_needle(n)\n        if pi_est_buffon != np.inf:\n            buffon_errors.append(abs(pi_est_buffon - np.pi))\n        else:\n            buffon_errors.append(np.nan)\n\n    plt.figure(figsize=(10, 6))\n    plt.loglog(points, circle_errors, 'b-', label='Circle Method')\n    plt.loglog(points, buffon_errors, 'r-', label='Buffon\\'s Needle')\n    plt.grid(True)\n    plt.xlabel('Number of Points/Needles')\n    plt.ylabel('Absolute Error')\n    plt.title('Comparison of Method Convergence')\n    plt.legend()\n    plt.show()\n\ncompare_methods()\n</code></pre> <p></p>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-conclusions","title":"4. Conclusions","text":"<ol> <li> <p>Convergence Rate</p> <ul> <li>The circle method generally shows more stable convergence</li> <li>Buffon's needle method has higher variance in its estimates</li> </ul> </li> <li> <p>Computational Efficiency</p> <ul> <li>Circle method is simpler to implement and computationally lighter</li> <li>Buffon's needle requires more complex geometric calculations</li> </ul> </li> <li> <p>Practical Considerations</p> <ul> <li>Both methods demonstrate the power of Monte Carlo techniques</li> <li>The circle method is more suitable for educational purposes</li> <li>Buffon's needle provides an interesting historical and geometric perspective</li> </ul> </li> </ol>"},{"location":"1%20Physics/6%20Statistics/Problem_2/#5-applications","title":"5. Applications","text":"<ul> <li>Random number generation testing</li> <li>Introduction to Monte Carlo methods</li> <li>Teaching probability and geometric concepts</li> <li>Demonstration of law of large numbers</li> </ul> <p>The Monte Carlo estimation of \u03c0 serves as an excellent introduction to computational methods in physics and mathematics, demonstrating how random sampling can be used to solve deterministic problems.</p>"},{"location":"1%20Physics/7%20Measurements/Problem_1/","title":"Problem 1","text":"<p>Measuring Earth's Gravitational Acceleration with a Pendulum</p>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-theoretical-background","title":"1. Theoretical Background","text":"<p>The simple pendulum is a classic example of a harmonic oscillator. For small angles (\u03b8 &lt; 15\u00b0), the period T of a simple pendulum is given by:</p> \\[ T = 2\\pi\\sqrt{\\frac{L}{g}} \\] <p>where: - T is the period of oscillation - L is the length of the pendulum - g is the acceleration due to gravity</p> <p>This relationship allows us to determine g by measuring T and L:</p> \\[ g = \\frac{4\\pi^2 L}{T^2} \\]"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-experimental-setup-and-data-collection","title":"2. Experimental Setup and Data Collection","text":""},{"location":"1%20Physics/7%20Measurements/Problem_1/#21-materials-used","title":"2.1 Materials Used","text":"<ul> <li>String length: 1.2 m</li> <li>Weight: 100g metal sphere</li> <li>Measuring tape (resolution: 1 mm)</li> <li>Smartphone stopwatch (resolution: 0.01 s)</li> </ul>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#22-measurement-process-and-analysis","title":"2.2 Measurement Process and Analysis","text":"<pre><code># Import required libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nfrom IPython.display import display, HTML\n\n# Set basic plot style\nplt.style.use('default')\nplt.rcParams['figure.figsize'] = [10, 6]\nplt.rcParams['axes.grid'] = True\nplt.rcParams['font.size'] = 12\n\n# Example data from measurements\nL = 1.2  # meters\ndelta_L = 0.0005  # uncertainty in length (half of measuring tape resolution)\n\n# Time measurements for 10 oscillations (simulated data)\nT_10_measurements = np.array([\n    22.15, 22.18, 22.12, 22.16, 22.14,\n    22.17, 22.13, 22.15, 22.16, 22.14\n])\n\n# Calculate mean and standard deviation\nT_10_mean = np.mean(T_10_measurements)\nT_10_std = np.std(T_10_measurements, ddof=1)  # ddof=1 for sample standard deviation\ndelta_T_10 = T_10_std / np.sqrt(len(T_10_measurements))\n\n# Calculate period and its uncertainty\nT = T_10_mean / 10\ndelta_T = delta_T_10 / 10\n\n# Create visualization of time measurements\nplt.figure(figsize=(10, 6))\nplt.errorbar(range(1, 11), T_10_measurements, yerr=0.01, fmt='o', \n             capsize=5, label='Measurements', color='blue')\nplt.axhline(y=T_10_mean, color='red', linestyle='--', \n            label=f'Mean = {T_10_mean:.2f} s')\nplt.fill_between(range(1, 11), \n                 T_10_mean - T_10_std, T_10_mean + T_10_std, \n                 alpha=0.2, color='red', label=f'\u00b11\u03c3 = {T_10_std:.3f} s')\nplt.xlabel('Measurement Number')\nplt.ylabel('Time for 10 Oscillations (s)')\nplt.title('Time Measurements Distribution')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Create a normal probability plot with histogram\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n\n# Histogram\ncounts, bins, _ = ax1.hist(T_10_measurements, bins=5, density=True, alpha=0.7, color='blue')\n# Add normal distribution curve\nmu, sigma = np.mean(T_10_measurements), np.std(T_10_measurements)\nx = np.linspace(mu - 3*sigma, mu + 3*sigma, 100)\nax1.plot(x, stats.norm.pdf(x, mu, sigma), 'r-', lw=2, label='Normal Distribution')\nax1.set_title('Distribution of Time Measurements')\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('Density')\nax1.legend()\n\n# Q-Q plot\nstats.probplot(T_10_measurements, dist=\"norm\", plot=ax2)\nax2.set_title('Normal Probability Plot')\nplt.tight_layout()\nplt.show()\n\n# Calculate g and its uncertainty\ng = 4 * np.pi**2 * L / T**2\ndelta_g = g * np.sqrt((delta_L/L)**2 + (2*delta_T/T)**2)\n\nprint(f\"Calculated g = {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2\")\n\n# Create visualization of uncertainty contributions\nuncertainties = {\n    'Length': (delta_L/L)**2,\n    'Time': (2*delta_T/T)**2\n}\n\nplt.figure(figsize=(8, 6))\nplt.bar(uncertainties.keys(), uncertainties.values(), color=['blue', 'red'])\nplt.title('Relative Contributions to Uncertainty in g')\nplt.ylabel('Squared Relative Uncertainty')\nplt.yscale('log')\nplt.grid(True)\nplt.show()\n\n# Create a visualization of how g varies with L and T\nL_range = np.linspace(L - 5*delta_L, L + 5*delta_L, 100)\nT_range = np.linspace(T - 5*delta_T, T + 5*delta_T, 100)\n\nL_grid, T_grid = np.meshgrid(L_range, T_range)\ng_grid = 4 * np.pi**2 * L_grid / T_grid**2\n\nplt.figure(figsize=(10, 6))\ncontour = plt.contour(L_grid, T_grid, g_grid, levels=20)\nplt.colorbar(contour, label='g (m/s\u00b2)')\nplt.plot(L, T, 'r*', markersize=15, label='Measured Values')\nplt.xlabel('Length (m)')\nplt.ylabel('Period (s)')\nplt.title('Dependence of g on L and T')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#23-data-summary","title":"2.3 Data Summary","text":"Parameter Value Uncertainty Length (L) 1.200 m \u00b10.0005 m Time for 10 oscillations (T\u2081\u2080) 22.15 s \u00b10.006 s Period (T) 2.215 s \u00b10.0006 s"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-analysis-of-results","title":"3. Analysis of Results","text":""},{"location":"1%20Physics/7%20Measurements/Problem_1/#31-comparison-with-expected-value","title":"3.1 Comparison with Expected Value","text":"<p>The accepted value of g at sea level is approximately 9.81 m/s\u00b2. Our measurement:</p> <p>g = (9.807 \u00b1 0.008) m/s\u00b2</p> <p>The relative uncertainty in our measurement is: $$ \\frac{\\Delta g}{g} \\times 100\\% = 0.08\\% $$</p>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#32-sources-of-systematic-uncertainty","title":"3.2 Sources of Systematic Uncertainty","text":"<ol> <li>Length Measurement:</li> <li>Uncertainty in determining the center of mass of the bob</li> <li>String stretching during oscillation</li> <li> <p>Parallax errors in measurement</p> </li> <li> <p>Time Measurement:</p> </li> <li>Human reaction time in starting/stopping the timer</li> <li>Difficulty in determining exact completion of oscillation</li> <li> <p>Damping effects over multiple oscillations</p> </li> <li> <p>Environmental Factors:</p> </li> <li>Air resistance</li> <li>Temperature effects on string length</li> <li>Local variations in g due to altitude and latitude</li> </ol>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-conclusions","title":"4. Conclusions","text":"<p>Our experimental value of g = (9.807 \u00b1 0.008) m/s\u00b2 agrees well with the accepted value of 9.81 m/s\u00b2 within our uncertainty bounds. The primary sources of uncertainty were:</p> <ol> <li>Timing precision (contributing ~80% of total uncertainty)</li> <li>Length measurement (contributing ~20% of total uncertainty)</li> </ol> <p>The experiment demonstrates the effectiveness of the simple pendulum method for measuring g, achieving a precision of better than 0.1%.</p>"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-references","title":"5. References","text":"<ol> <li>Young, H. D., &amp; Freedman, R. A. (2020). University Physics with Modern Physics (15th ed.)</li> <li>Taylor, J. R. (1997). An Introduction to Error Analysis (2nd ed.)</li> <li>NIST Reference on Constants, Units, and Uncertainty</li> </ol>"},{"location":"2%20Mathematics/1%20Linear_algebra/","title":"Linear Algebra","text":""},{"location":"2%20Mathematics/2%20Analytic_geometry/","title":"Analytic geometry","text":""},{"location":"2%20Mathematics/3%20Calculus/","title":"Calculus","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","title":"Set Theory","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","title":"Relations","text":""},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","title":"Functions","text":""},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","title":"Combinatorics","text":""},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","title":"Number Theory","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","title":"Sequences and Series","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","title":"Induction","text":""},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","title":"Recurrence","text":""},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","title":"Graph Theory","text":""},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","title":"Logic","text":""}]}