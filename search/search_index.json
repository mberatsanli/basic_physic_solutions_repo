{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Motion Projectile motion can be analyzed using Newton's laws of motion. For a more complete analysis, let's start with the fundamental differential equations: \\[ \\frac{d^2x}{dt^2} = 0 $$ $$ \\frac{d^2y}{dt^2} = -g \\] Integrating these equations with initial conditions: $$ v_{0x} = v_0\\cos(\\theta) $$ $$ v_{0y} = v_0\\sin(\\theta) $$ We get the velocity components: $$ v_x(t) = v_0\\cos(\\theta) $$ $$ v_y(t) = v_0\\sin(\\theta) - gt $$ And the position components: $$ x(t) = v_0\\cos(\\theta)t $$ $$ y(t) = v_0\\sin(\\theta)t - \\frac{1}{2}gt^2 $$ Enhanced Analysis of Flight Characteristics Maximum Height: The maximum height occurs when \\(v_y(t) = 0\\) : $$ h_{max} = \\frac{v_0^2\\sin^2(\\theta)}{2g} $$ Time of Flight: \\[ t_f = \\frac{2v_0\\sin(\\theta)}{g} \\] Range Formula: \\[ R = \\frac{v_0^2\\sin(2\\theta)}{g} \\] Let's create a more comprehensive visualization that shows both the trajectory and range analysis: import numpy as np import matplotlib.pyplot as plt from matplotlib.gridspec import GridSpec def trajectory(t, v0, theta, g=9.81): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s g = 9.81 # gravity # Create figure with GridSpec fig = plt.figure(figsize=(15, 10)) gs = GridSpec(2, 2, figure=fig) # Plot 1: Range vs Angle ax1 = fig.add_subplot(gs[0, 0]) theta = np.linspace(0, 90, 100) ranges = range_function(theta, v0, g) ax1.plot(theta, ranges, 'b-', label=f'v0 = {v0} m/s') ax1.set_xlabel('Launch Angle (degrees)') ax1.set_ylabel('Range (m)') ax1.set_title('Range vs Launch Angle') ax1.grid(True) ax1.legend() # Plot 2: Multiple Trajectories ax2 = fig.add_subplot(gs[0, 1]) angles = [15, 30, 45, 60, 75] t = np.linspace(0, 3, 100) for angle in angles: x, y = trajectory(t, v0, angle) ax2.plot(x, y, label=f'\u03b8 = {angle}\u00b0') ax2.set_xlabel('Distance (m)') ax2.set_ylabel('Height (m)') ax2.set_title('Projectile Trajectories') ax2.grid(True) ax2.legend() # Plot 3: Range vs Initial Velocity ax3 = fig.add_subplot(gs[1, 0]) v0_range = np.linspace(0, 30, 100) theta_fixed = 45 # optimal angle ranges_v0 = range_function(theta_fixed, v0_range) ax3.plot(v0_range, ranges_v0, 'r-') ax3.set_xlabel('Initial Velocity (m/s)') ax3.set_ylabel('Range (m)') ax3.set_title('Range vs Initial Velocity (\u03b8 = 45\u00b0)') ax3.grid(True) # Plot 4: Maximum Height vs Angle ax4 = fig.add_subplot(gs[1, 1]) h_max = (v0**2 * np.sin(np.radians(theta))**2) / (2*g) ax4.plot(theta, h_max, 'g-') ax4.set_xlabel('Launch Angle (degrees)') ax4.set_ylabel('Maximum Height (m)') ax4.set_title('Maximum Height vs Launch Angle') ax4.grid(True) plt.tight_layout() plt.show() Advanced Analysis with Air Resistance When considering air resistance, the equations become: \\[ m\\frac{d^2x}{dt^2} = -kv_x|v| $$ $$ m\\frac{d^2y}{dt^2} = -mg - kv_y|v| \\] where \\(k\\) is the drag coefficient and \\(|v|\\) is the magnitude of velocity. Let's simulate this using numerical integration: from scipy.integrate import odeint def projectile_with_drag(state, t, k, m, g): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) dxdt = vx dydt = vy dvxdt = -k/m * vx * v dvydt = -g - k/m * vy * v return [dxdt, dydt, dvxdt, dvydt] # Parameters m = 1.0 # mass in kg k = 0.1 # drag coefficient t = np.linspace(0, 2, 1000) theta = 45 # degrees # Initial conditions v0 = 20 state0 = [0, 0, v0*np.cos(np.radians(theta)), v0*np.sin(np.radians(theta))] # Solve ODE solution = odeint(projectile_with_drag, state0, t, args=(k, m, g)) plt.figure(figsize=(10, 6)) plt.plot(solution[:, 0], solution[:, 1], 'b-', label='With drag') x_no_drag, y_no_drag = trajectory(t, v0, theta) plt.plot(x_no_drag, y_no_drag, 'r--', label='Without drag') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Comparison of Trajectories With and Without Air Resistance') plt.grid(True) plt.legend() plt.show() 2. Analysis of the Range Influence of Initial Conditions Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) . Graphical Representation Below is a Python script to visualize how the range changes with \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() 3. Practical Applications Sports : Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin. Engineering : Used in ballistics, military applications, and designing trajectories for rockets and missiles. Astrophysics : Used to model celestial body trajectories and space exploration missions. 4. Implementation A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve. Example: Adding Air Resistance The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions. 5. Limitations and Further Considerations Air resistance : Causes asymmetry and reduces range. Uneven terrain : Requires solving for complex boundary conditions. Wind effects : Affects trajectory unpredictably. Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments. Conclusion Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","text":"Projectile motion can be analyzed using Newton's laws of motion. For a more complete analysis, let's start with the fundamental differential equations: \\[ \\frac{d^2x}{dt^2} = 0 $$ $$ \\frac{d^2y}{dt^2} = -g \\] Integrating these equations with initial conditions: $$ v_{0x} = v_0\\cos(\\theta) $$ $$ v_{0y} = v_0\\sin(\\theta) $$ We get the velocity components: $$ v_x(t) = v_0\\cos(\\theta) $$ $$ v_y(t) = v_0\\sin(\\theta) - gt $$ And the position components: $$ x(t) = v_0\\cos(\\theta)t $$ $$ y(t) = v_0\\sin(\\theta)t - \\frac{1}{2}gt^2 $$","title":"Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhanced-analysis-of-flight-characteristics","text":"","title":"Enhanced Analysis of Flight Characteristics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"The maximum height occurs when \\(v_y(t) = 0\\) : $$ h_{max} = \\frac{v_0^2\\sin^2(\\theta)}{2g} $$","title":"Maximum Height:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"\\[ t_f = \\frac{2v_0\\sin(\\theta)}{g} \\]","title":"Time of Flight:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"\\[ R = \\frac{v_0^2\\sin(2\\theta)}{g} \\] Let's create a more comprehensive visualization that shows both the trajectory and range analysis: import numpy as np import matplotlib.pyplot as plt from matplotlib.gridspec import GridSpec def trajectory(t, v0, theta, g=9.81): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s g = 9.81 # gravity # Create figure with GridSpec fig = plt.figure(figsize=(15, 10)) gs = GridSpec(2, 2, figure=fig) # Plot 1: Range vs Angle ax1 = fig.add_subplot(gs[0, 0]) theta = np.linspace(0, 90, 100) ranges = range_function(theta, v0, g) ax1.plot(theta, ranges, 'b-', label=f'v0 = {v0} m/s') ax1.set_xlabel('Launch Angle (degrees)') ax1.set_ylabel('Range (m)') ax1.set_title('Range vs Launch Angle') ax1.grid(True) ax1.legend() # Plot 2: Multiple Trajectories ax2 = fig.add_subplot(gs[0, 1]) angles = [15, 30, 45, 60, 75] t = np.linspace(0, 3, 100) for angle in angles: x, y = trajectory(t, v0, angle) ax2.plot(x, y, label=f'\u03b8 = {angle}\u00b0') ax2.set_xlabel('Distance (m)') ax2.set_ylabel('Height (m)') ax2.set_title('Projectile Trajectories') ax2.grid(True) ax2.legend() # Plot 3: Range vs Initial Velocity ax3 = fig.add_subplot(gs[1, 0]) v0_range = np.linspace(0, 30, 100) theta_fixed = 45 # optimal angle ranges_v0 = range_function(theta_fixed, v0_range) ax3.plot(v0_range, ranges_v0, 'r-') ax3.set_xlabel('Initial Velocity (m/s)') ax3.set_ylabel('Range (m)') ax3.set_title('Range vs Initial Velocity (\u03b8 = 45\u00b0)') ax3.grid(True) # Plot 4: Maximum Height vs Angle ax4 = fig.add_subplot(gs[1, 1]) h_max = (v0**2 * np.sin(np.radians(theta))**2) / (2*g) ax4.plot(theta, h_max, 'g-') ax4.set_xlabel('Launch Angle (degrees)') ax4.set_ylabel('Maximum Height (m)') ax4.set_title('Maximum Height vs Launch Angle') ax4.grid(True) plt.tight_layout() plt.show()","title":"Range Formula:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#advanced-analysis-with-air-resistance","text":"When considering air resistance, the equations become: \\[ m\\frac{d^2x}{dt^2} = -kv_x|v| $$ $$ m\\frac{d^2y}{dt^2} = -mg - kv_y|v| \\] where \\(k\\) is the drag coefficient and \\(|v|\\) is the magnitude of velocity. Let's simulate this using numerical integration: from scipy.integrate import odeint def projectile_with_drag(state, t, k, m, g): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) dxdt = vx dydt = vy dvxdt = -k/m * vx * v dvydt = -g - k/m * vy * v return [dxdt, dydt, dvxdt, dvydt] # Parameters m = 1.0 # mass in kg k = 0.1 # drag coefficient t = np.linspace(0, 2, 1000) theta = 45 # degrees # Initial conditions v0 = 20 state0 = [0, 0, v0*np.cos(np.radians(theta)), v0*np.sin(np.radians(theta))] # Solve ODE solution = odeint(projectile_with_drag, state0, t, args=(k, m, g)) plt.figure(figsize=(10, 6)) plt.plot(solution[:, 0], solution[:, 1], 'b-', label='With drag') x_no_drag, y_no_drag = trajectory(t, v0, theta) plt.plot(x_no_drag, y_no_drag, 'r--', label='Without drag') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Comparison of Trajectories With and Without Air Resistance') plt.grid(True) plt.legend() plt.show()","title":"Advanced Analysis with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-conditions","text":"Initial velocity ( \\( v_0 \\) ) : Increasing \\( v_0 \\) increases the range quadratically. Gravitational acceleration ( \\( g \\) ) : Higher \\( g \\) reduces the range, as the projectile falls more quickly. Launch angle ( \\( \\theta \\) ) : The range follows a symmetric pattern, peaking at \\( 45^\\circ \\) .","title":"Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","text":"Below is a Python script to visualize how the range changes with \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt def range_function(theta, v0, g=9.81): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Parameters v0 = 20 # initial velocity in m/s theta = np.linspace(0, 90, 100) # range of angles g = 9.81 # gravity # Compute ranges ranges = range_function(theta, v0, g) # Plot results plt.figure(figsize=(8,5)) plt.plot(theta, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Understanding projectile motion helps in optimizing the throwing angles in sports like basketball, soccer, and javelin. Engineering : Used in ballistics, military applications, and designing trajectories for rockets and missiles. Astrophysics : Used to model celestial body trajectories and space exploration missions.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"A numerical simulation can further analyze cases involving air resistance. Incorporating drag force leads to differential equations that require numerical methods (e.g., Runge-Kutta) to solve.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-adding-air-resistance","text":"The equations with drag \\(F_d = -k v^2\\) lead to: \\[m \\frac{d^2 x}{dt^2} = -k v_x^2$$ $$m \\frac{d^2 y}{dt^2} = -mg - k v_y^2\\] A numerical solver like Python's SciPy can be used to compute solutions.","title":"Example: Adding Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-considerations","text":"Air resistance : Causes asymmetry and reduces range. Uneven terrain : Requires solving for complex boundary conditions. Wind effects : Affects trajectory unpredictably. Future work could involve incorporating machine learning techniques to predict projectile trajectories in complex environments.","title":"5. Limitations and Further Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"Projectile motion demonstrates rich mathematical and physical insights. While the idealized model provides a good approximation, real-world adaptations require numerical solutions to account for non-ideal conditions.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small Angles For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics. 2. Analysis of Dynamics Influence of System Parameters Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge. Transition to Chaos By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary. 3. Practical Applications The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices : Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges : Helps in understanding oscillations leading to structural failures. - Electrical Circuits : Analogous to driven RLC circuits with damping and external forcing. 4. Implementation Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Enhanced parameter set b_values = [0.1, 0.5, 1.0] # different damping coefficients g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Create subplots for different analyses plt.figure(figsize=(15, 10)) # Plot 1: Compare different damping coefficients plt.subplot(2, 2, 1) for b in b_values: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) plt.plot(sol.t, sol.y[0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient') plt.legend() plt.grid(True) # Plot 2: Phase Space Portrait plt.subplot(2, 2, 2) b = 0.2 # Use moderate damping for phase space sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) plt.plot(sol.y[0], sol.y[1]) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Space Portrait') plt.grid(True) # Plot 3: Resonance Analysis frequencies = np.linspace(0.5, 4, 50) amplitudes = [] b = 0.2 for w in frequencies: sol = solve_ivp(forced_damped_pendulum, (0, 100), y0, t_eval=np.linspace(80, 100, 200), args=(b, g, L, A, w)) amplitudes.append(np.max(np.abs(sol.y[0]))) plt.subplot(2, 2, 3) plt.plot(frequencies, amplitudes) plt.xlabel('Driving Frequency \u03c9 (rad/s)') plt.ylabel('Maximum Amplitude (rad)') plt.title('Resonance Curve') plt.grid(True) # Plot 4: Energy Analysis def system_energy(theta, omega, L, g): kinetic = 0.5 * L**2 * omega**2 potential = g * L * (1 - np.cos(theta)) return kinetic + potential b = 0.2 sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) energies = [system_energy(theta, omega, L, g) for theta, omega in zip(sol.y[0], sol.y[1])] plt.subplot(2, 2, 4) plt.plot(sol.t, energies) plt.xlabel('Time (s)') plt.ylabel('Total Energy (J)') plt.title('System Energy Evolution') plt.grid(True) plt.tight_layout() plt.show() # 3D Phase Space Trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') b = 0.2 sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) ax.plot(sol.y[0], sol.y[1], sol.t) ax.set_xlabel('\u03b8 (rad)') ax.set_ylabel('d\u03b8/dt (rad/s)') ax.set_zlabel('Time (s)') ax.set_title('3D Phase Space Trajectory') plt.show() # Poincar\u00e9 Section plt.figure(figsize=(8, 8)) t_long = np.linspace(0, 200, 4000) sol = solve_ivp(forced_damped_pendulum, (0, 200), y0, t_eval=t_long, args=(b, g, L, A, omega)) # Sample points at driving period period = 2*np.pi/omega indices = [i for i in range(len(t_long)) if abs((t_long[i] % period)) < 0.1] plt.scatter(sol.y[0][indices], sol.y[1][indices], s=1) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid(True) plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time. 5. Limitations and Extensions Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Nonlinear damping (e.g., air drag proportional to velocity squared). Non-periodic driving forces to model irregular forcing. Coupled pendulum systems for synchronization studies. 6. Conclusion The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angles","text":"For small angles ( \\( \\theta \\approx \\sin \\theta \\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This corresponds to a damped, driven harmonic oscillator, which can be solved using standard methods. The steady-state solution takes the form: \\[ \\theta(t) = \\theta_0 e^{-bt/2} + C \\cos(\\omega t - \\phi) \\] where \\( C \\) and \\( \\phi \\) depend on \\( A, b, \\omega \\) , and system parameters.","title":"Approximate Solutions for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 = \\sqrt{g/L} \\) , leading to large oscillations. At resonance, energy transfer is maximized, which has practical implications in engineering and physics.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-system-parameters","text":"Damping Coefficient ( \\( b \\) ) : Higher damping suppresses oscillations and prevents chaotic motion. Driving Amplitude ( \\( A \\) ) : Larger amplitudes can induce chaotic behavior and bifurcations. Driving Frequency ( \\( \\omega \\) ) : At specific values, resonance or chaos can emerge.","title":"Influence of System Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"By varying \\( A \\) and \\( \\omega \\) , the system transitions from periodic oscillations to quasiperiodic and chaotic motion. These can be analyzed using: Phase Diagrams : Plots of \\( \\theta \\) vs. \\( d\\theta/dt \\) to visualize stability. Poincar\u00e9 Sections : Discrete-time slices revealing periodicity or chaos. Bifurcation Diagrams : Showing system behavior changes as parameters vary.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to various real-world systems: - Energy Harvesting Devices : Used to optimize mechanical-to-electrical energy conversion. - Suspension Bridges : Helps in understanding oscillations leading to structural failures. - Electrical Circuits : Analogous to driven RLC circuits with damping and external forcing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Below is a Python script to simulate and visualize the forced damped pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D def forced_damped_pendulum(t, y, b, g, L, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Enhanced parameter set b_values = [0.1, 0.5, 1.0] # different damping coefficients g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) A = 1.2 # driving force amplitude omega = 2.0 # driving frequency y0 = [0.1, 0] # initial conditions: [theta(0), omega(0)] t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Create subplots for different analyses plt.figure(figsize=(15, 10)) # Plot 1: Compare different damping coefficients plt.subplot(2, 2, 1) for b in b_values: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) plt.plot(sol.t, sol.y[0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient') plt.legend() plt.grid(True) # Plot 2: Phase Space Portrait plt.subplot(2, 2, 2) b = 0.2 # Use moderate damping for phase space sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) plt.plot(sol.y[0], sol.y[1]) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Space Portrait') plt.grid(True) # Plot 3: Resonance Analysis frequencies = np.linspace(0.5, 4, 50) amplitudes = [] b = 0.2 for w in frequencies: sol = solve_ivp(forced_damped_pendulum, (0, 100), y0, t_eval=np.linspace(80, 100, 200), args=(b, g, L, A, w)) amplitudes.append(np.max(np.abs(sol.y[0]))) plt.subplot(2, 2, 3) plt.plot(frequencies, amplitudes) plt.xlabel('Driving Frequency \u03c9 (rad/s)') plt.ylabel('Maximum Amplitude (rad)') plt.title('Resonance Curve') plt.grid(True) # Plot 4: Energy Analysis def system_energy(theta, omega, L, g): kinetic = 0.5 * L**2 * omega**2 potential = g * L * (1 - np.cos(theta)) return kinetic + potential b = 0.2 sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) energies = [system_energy(theta, omega, L, g) for theta, omega in zip(sol.y[0], sol.y[1])] plt.subplot(2, 2, 4) plt.plot(sol.t, energies) plt.xlabel('Time (s)') plt.ylabel('Total Energy (J)') plt.title('System Energy Evolution') plt.grid(True) plt.tight_layout() plt.show() # 3D Phase Space Trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') b = 0.2 sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(b, g, L, A, omega)) ax.plot(sol.y[0], sol.y[1], sol.t) ax.set_xlabel('\u03b8 (rad)') ax.set_ylabel('d\u03b8/dt (rad/s)') ax.set_zlabel('Time (s)') ax.set_title('3D Phase Space Trajectory') plt.show() # Poincar\u00e9 Section plt.figure(figsize=(8, 8)) t_long = np.linspace(0, 200, 4000) sol = solve_ivp(forced_damped_pendulum, (0, 200), y0, t_eval=t_long, args=(b, g, L, A, omega)) # Sample points at driving period period = 2*np.pi/omega indices = [i for i in range(len(t_long)) if abs((t_long[i] % period)) < 0.1] plt.scatter(sol.y[0][indices], sol.y[1][indices], s=1) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid(True) plt.show() This script numerically solves the pendulum equation and plots \\( \\theta(t) \\) over time.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-limitations-and-extensions","text":"Limitations : Assumes a point mass pendulum, ignores friction and air resistance. Extensions : Nonlinear damping (e.g., air drag proportional to velocity squared). Non-periodic driving forces to model irregular forcing. Coupled pendulum systems for synchronization studies.","title":"5. Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum demonstrates a wide range of behaviors, from simple harmonic motion to chaos. By adjusting damping, forcing, and frequency, we can explore resonance, stability, and chaotic dynamics, providing insights into both fundamental physics and engineering applications.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius 1. Theoretical Foundation 1.1 Basic Principles The relationship between orbital period and radius emerges from two fundamental principles: 1. Newton's Law of Universal Gravitation 2. Centripetal Force For a body in circular orbit: \\[ F_g = F_c \\] \\[ \\frac{GMm}{r^2} = m\\frac{v^2}{r} \\] where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity 1.2 Derivation of Kepler's Third Law For circular orbits, the velocity can be expressed as: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation: \\[ \\frac{GMm}{r^2} = m\\frac{4\\pi^2r^2}{T^2r} \\] Simplifying: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] This is Kepler's Third Law in its exact form, showing that: \\[ T^2 \\propto r^3 \\] 2. Computational Analysis Let's create a comprehensive visualization suite to analyze orbital dynamics: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.gridspec import GridSpec # Constants G = 6.67430e-11 # Gravitational constant M_earth = 5.972e24 # Earth mass in kg M_sun = 1.989e30 # Sun mass in kg def orbital_period(radius, central_mass): return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def plot_orbit_3d(ax, radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) z = np.zeros_like(theta) ax.plot(x, y, z) # Create figure with multiple subplots fig = plt.figure(figsize=(15, 12)) gs = GridSpec(2, 2, figure=fig) # Plot 1: T\u00b2 vs r\u00b3 relationship ax1 = fig.add_subplot(gs[0, 0]) radii = np.linspace(1e8, 1e9, 100) periods = orbital_period(radii, M_earth) T_squared = periods**2 r_cubed = radii**3 ax1.plot(r_cubed, T_squared, 'b-', label='Earth Satellites') ax1.set_xlabel('Orbital Radius Cubed (m\u00b3)') ax1.set_ylabel('Period Squared (s\u00b2)') ax1.set_title(\"Kepler's Third Law Verification\") ax1.grid(True) ax1.legend() # Plot 2: 3D Orbital Visualization ax2 = fig.add_subplot(gs[0, 1], projection='3d') radii_3d = [4e8, 6e8, 8e8] colors = ['b', 'g', 'r'] for r, c in zip(radii_3d, colors): plot_orbit_3d(ax2, r) ax2.scatter([0], [0], [0], color='yellow', s=100, label='Earth') ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_zlabel('Z (m)') ax2.set_title('3D Visualization of Circular Orbits') # Plot 3: Orbital Velocity vs Radius ax3 = fig.add_subplot(gs[1, 0]) radii_v = np.linspace(1e7, 1e9, 100) velocities = np.sqrt(G * M_earth / radii_v) ax3.plot(radii_v, velocities, 'r-') ax3.set_xlabel('Orbital Radius (m)') ax3.set_ylabel('Orbital Velocity (m/s)') ax3.set_title('Orbital Velocity vs Radius') ax3.grid(True) # Plot 4: Energy Analysis ax4 = fig.add_subplot(gs[1, 1]) kinetic_energy = 0.5 * velocities**2 potential_energy = -G * M_earth / radii_v total_energy = kinetic_energy + potential_energy ax4.plot(radii_v, kinetic_energy, 'b-', label='Kinetic Energy') ax4.plot(radii_v, potential_energy, 'r-', label='Potential Energy') ax4.plot(radii_v, total_energy, 'g-', label='Total Energy') ax4.set_xlabel('Orbital Radius (m)') ax4.set_ylabel('Energy per unit mass (J/kg)') ax4.set_title('Orbital Energy Analysis') ax4.grid(True) ax4.legend() plt.tight_layout() plt.show() 3. Real-World Applications 3.1 Satellite Orbits Let's analyze different types of satellite orbits: import numpy as np import matplotlib.pyplot as plt # Constants for common satellite orbits LEO_height = 400e3 # Low Earth Orbit GEO_height = 35786e3 # Geostationary Orbit R_earth = 6371e3 # Earth radius def plot_satellite_orbits(): fig, ax = plt.subplots(figsize=(10, 10)) # Plot Earth earth_circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth') ax.add_artist(earth_circle) # Plot orbits theta = np.linspace(0, 2*np.pi, 100) # LEO leo_radius = R_earth + LEO_height ax.plot(leo_radius*np.cos(theta), leo_radius*np.sin(theta), 'r-', label='LEO') # GEO geo_radius = R_earth + GEO_height ax.plot(geo_radius*np.cos(theta), geo_radius*np.sin(theta), 'g-', label='GEO') ax.set_aspect('equal') ax.grid(True) ax.set_xlabel('Distance (m)') ax.set_ylabel('Distance (m)') ax.set_title('Common Satellite Orbits') ax.legend() # Set limits to show both orbits clearly limit = GEO_height + R_earth ax.set_xlim(-limit, limit) ax.set_ylim(-limit, limit) plt.show() plot_satellite_orbits() 3.2 Solar System Analysis The relationship extends to planetary orbits: Planet Orbital Period (years) Semi-major Axis (AU) T\u00b2/r\u00b3 (constant) Mercury 0.24 0.39 1.00 Venus 0.62 0.72 1.00 Earth 1.00 1.00 1.00 Mars 1.88 1.52 1.00 4. Limitations and Extensions Elliptical Orbits : For non-circular orbits, r becomes the semi-major axis. Relativistic Effects : At high velocities or strong gravitational fields, corrections are needed. Multi-body Systems : Additional terms required for n-body problems. 5. Conclusion Kepler's Third Law provides a powerful tool for understanding orbital dynamics, from artificial satellites to planetary motion. The computational models demonstrate the precise mathematical relationships governing orbital motion and provide insights into the design of space missions and the study of celestial mechanics. References Classical Mechanics (Goldstein) Orbital Mechanics for Engineering Students (Curtis) Fundamentals of Astrodynamics (Bate, Mueller, White)","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Orbital Period and Orbital Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-basic-principles","text":"The relationship between orbital period and radius emerges from two fundamental principles: 1. Newton's Law of Universal Gravitation 2. Centripetal Force For a body in circular orbit: \\[ F_g = F_c \\] \\[ \\frac{GMm}{r^2} = m\\frac{v^2}{r} \\] where: - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the central body - \\(m\\) is the mass of the orbiting body - \\(r\\) is the orbital radius - \\(v\\) is the orbital velocity","title":"1.1 Basic Principles"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-derivation-of-keplers-third-law","text":"For circular orbits, the velocity can be expressed as: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation: \\[ \\frac{GMm}{r^2} = m\\frac{4\\pi^2r^2}{T^2r} \\] Simplifying: \\[ T^2 = \\frac{4\\pi^2}{GM}r^3 \\] This is Kepler's Third Law in its exact form, showing that: \\[ T^2 \\propto r^3 \\]","title":"1.2 Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-computational-analysis","text":"Let's create a comprehensive visualization suite to analyze orbital dynamics: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.gridspec import GridSpec # Constants G = 6.67430e-11 # Gravitational constant M_earth = 5.972e24 # Earth mass in kg M_sun = 1.989e30 # Sun mass in kg def orbital_period(radius, central_mass): return 2 * np.pi * np.sqrt(radius**3 / (G * central_mass)) def plot_orbit_3d(ax, radius, num_points=100): theta = np.linspace(0, 2*np.pi, num_points) x = radius * np.cos(theta) y = radius * np.sin(theta) z = np.zeros_like(theta) ax.plot(x, y, z) # Create figure with multiple subplots fig = plt.figure(figsize=(15, 12)) gs = GridSpec(2, 2, figure=fig) # Plot 1: T\u00b2 vs r\u00b3 relationship ax1 = fig.add_subplot(gs[0, 0]) radii = np.linspace(1e8, 1e9, 100) periods = orbital_period(radii, M_earth) T_squared = periods**2 r_cubed = radii**3 ax1.plot(r_cubed, T_squared, 'b-', label='Earth Satellites') ax1.set_xlabel('Orbital Radius Cubed (m\u00b3)') ax1.set_ylabel('Period Squared (s\u00b2)') ax1.set_title(\"Kepler's Third Law Verification\") ax1.grid(True) ax1.legend() # Plot 2: 3D Orbital Visualization ax2 = fig.add_subplot(gs[0, 1], projection='3d') radii_3d = [4e8, 6e8, 8e8] colors = ['b', 'g', 'r'] for r, c in zip(radii_3d, colors): plot_orbit_3d(ax2, r) ax2.scatter([0], [0], [0], color='yellow', s=100, label='Earth') ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_zlabel('Z (m)') ax2.set_title('3D Visualization of Circular Orbits') # Plot 3: Orbital Velocity vs Radius ax3 = fig.add_subplot(gs[1, 0]) radii_v = np.linspace(1e7, 1e9, 100) velocities = np.sqrt(G * M_earth / radii_v) ax3.plot(radii_v, velocities, 'r-') ax3.set_xlabel('Orbital Radius (m)') ax3.set_ylabel('Orbital Velocity (m/s)') ax3.set_title('Orbital Velocity vs Radius') ax3.grid(True) # Plot 4: Energy Analysis ax4 = fig.add_subplot(gs[1, 1]) kinetic_energy = 0.5 * velocities**2 potential_energy = -G * M_earth / radii_v total_energy = kinetic_energy + potential_energy ax4.plot(radii_v, kinetic_energy, 'b-', label='Kinetic Energy') ax4.plot(radii_v, potential_energy, 'r-', label='Potential Energy') ax4.plot(radii_v, total_energy, 'g-', label='Total Energy') ax4.set_xlabel('Orbital Radius (m)') ax4.set_ylabel('Energy per unit mass (J/kg)') ax4.set_title('Orbital Energy Analysis') ax4.grid(True) ax4.legend() plt.tight_layout() plt.show()","title":"2. Computational Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-applications","text":"","title":"3. Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-satellite-orbits","text":"Let's analyze different types of satellite orbits: import numpy as np import matplotlib.pyplot as plt # Constants for common satellite orbits LEO_height = 400e3 # Low Earth Orbit GEO_height = 35786e3 # Geostationary Orbit R_earth = 6371e3 # Earth radius def plot_satellite_orbits(): fig, ax = plt.subplots(figsize=(10, 10)) # Plot Earth earth_circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth') ax.add_artist(earth_circle) # Plot orbits theta = np.linspace(0, 2*np.pi, 100) # LEO leo_radius = R_earth + LEO_height ax.plot(leo_radius*np.cos(theta), leo_radius*np.sin(theta), 'r-', label='LEO') # GEO geo_radius = R_earth + GEO_height ax.plot(geo_radius*np.cos(theta), geo_radius*np.sin(theta), 'g-', label='GEO') ax.set_aspect('equal') ax.grid(True) ax.set_xlabel('Distance (m)') ax.set_ylabel('Distance (m)') ax.set_title('Common Satellite Orbits') ax.legend() # Set limits to show both orbits clearly limit = GEO_height + R_earth ax.set_xlim(-limit, limit) ax.set_ylim(-limit, limit) plt.show() plot_satellite_orbits()","title":"3.1 Satellite Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-solar-system-analysis","text":"The relationship extends to planetary orbits: Planet Orbital Period (years) Semi-major Axis (AU) T\u00b2/r\u00b3 (constant) Mercury 0.24 0.39 1.00 Venus 0.62 0.72 1.00 Earth 1.00 1.00 1.00 Mars 1.88 1.52 1.00","title":"3.2 Solar System Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-limitations-and-extensions","text":"Elliptical Orbits : For non-circular orbits, r becomes the semi-major axis. Relativistic Effects : At high velocities or strong gravitational fields, corrections are needed. Multi-body Systems : Additional terms required for n-body problems.","title":"4. Limitations and Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"Kepler's Third Law provides a powerful tool for understanding orbital dynamics, from artificial satellites to planetary motion. The computational models demonstrate the precise mathematical relationships governing orbital motion and provide insights into the design of space missions and the study of celestial mechanics.","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Classical Mechanics (Goldstein) Orbital Mechanics for Engineering Students (Curtis) Fundamentals of Astrodynamics (Bate, Mueller, White)","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Theoretical Foundation 1.1 Basic Principles of Gravitational Escape The concept of escape velocity emerges from the principle of energy conservation. For an object to escape a celestial body's gravitational field, its kinetic energy must equal or exceed the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\] Where: - \\(m\\) is the mass of the escaping object - \\(v\\) is the velocity - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius from the center of the celestial body 1.2 The Three Cosmic Velocities First Cosmic Velocity (Orbital Velocity) For circular orbit: Gravitational force equals centripetal force $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) From energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}v_1 $$ Third Cosmic Velocity (Solar System Escape Velocity) Combines planetary escape velocity with solar escape velocity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\(v_{sun}\\) is the orbital velocity around the Sun. Let's visualize these relationships with Python: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Set style plt.style.use('default') # Using default style instead of seaborn colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'] # Custom color palette def calculate_velocities(mass, radius, distance_from_sun=None): \"\"\"Calculate cosmic velocities for a celestial body\"\"\" v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 if distance_from_sun: v_sun = np.sqrt(G * 1.989e30 / distance_from_sun) # Sun's mass v3 = np.sqrt(v2**2 + v_sun**2) return v1, v2, v3 return v1, v2 # Celestial body data (mass in kg, radius in m, distance from sun in m) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.496e11), \"Mars\": (6.417e23, 3.389e6, 2.279e11), \"Jupiter\": (1.898e27, 6.9911e7, 7.786e11), \"Moon\": (7.34767309e22, 1.737e6, None), \"Mercury\": (3.285e23, 2.439e6, 5.79e10) } # Calculate velocities velocities = {body: calculate_velocities(mass, radius, dist) for body, (mass, radius, dist) in bodies.items()} # Create visualization fig = plt.figure(figsize=(15, 10)) gs = plt.GridSpec(2, 2) # Plot 1: Bar comparison ax1 = fig.add_subplot(gs[0, :]) bodies_list = list(bodies.keys()) v1_vals = [v[0]/1000 for v in velocities.values()] # Convert to km/s v2_vals = [v[1]/1000 for v in velocities.values()] v3_vals = [v[2]/1000 if len(v) > 2 else 0 for v in velocities.values()] x = np.arange(len(bodies_list)) width = 0.25 bars1 = ax1.bar(x - width, v1_vals, width, label='First Cosmic Velocity', color=colors[0]) bars2 = ax1.bar(x, v2_vals, width, label='Second Cosmic Velocity', color=colors[1]) bars3 = ax1.bar(x + width, v3_vals, width, label='Third Cosmic Velocity', color=colors[2]) ax1.set_ylabel('Velocity (km/s)') ax1.set_title('Comparison of Cosmic Velocities for Different Celestial Bodies') ax1.set_xticks(x) ax1.set_xticklabels(bodies_list) ax1.legend() ax1.grid(True, alpha=0.3) # Plot 2: Velocity vs Radius relationship ax2 = fig.add_subplot(gs[1, 0]) radii = np.linspace(1e6, 1e8, 1000) masses = [1e24, 5e24, 1e25] for i, mass in enumerate(masses): v1 = np.sqrt(G * mass / radii) ax2.plot(radii/1000, v1/1000, label=f'Mass = {mass:.1e} kg', color=colors[i]) ax2.set_xlabel('Radius (km)') ax2.set_ylabel('First Cosmic Velocity (km/s)') ax2.set_title('First Cosmic Velocity vs Radius') ax2.legend() ax2.set_xscale('log') ax2.set_yscale('log') ax2.grid(True, alpha=0.3) # Plot 3: Escape velocity field ax3 = fig.add_subplot(gs[1, 1]) x = np.linspace(-2, 2, 100) y = np.linspace(-2, 2, 100) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) V = np.sqrt(2*G*5.972e24/(R*6.371e6))/1000 # Earth's escape velocity field contour = ax3.contour(X, Y, V, levels=15, colors='black') ax3.clabel(contour, inline=True, fontsize=8) ax3.set_title('Earth Escape Velocity Field (km/s)') ax3.set_xlabel('Distance (Earth Radii)') ax3.set_ylabel('Distance (Earth Radii)') ax3.grid(True, alpha=0.3) plt.tight_layout() plt.show() 2. Analysis of Results 2.1 Velocity Relationships Let's examine how these velocities vary with distance from a celestial body: # Create distance-velocity relationship plot plt.figure(figsize=(10, 6)) distances = np.linspace(1, 10, 1000) # In Earth radii earth_mass = 5.972e24 earth_radius = 6.371e6 v1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000 v2 = np.sqrt(2) * v1 plt.plot(distances, v1, label='First Cosmic Velocity') plt.plot(distances, v2, label='Second Cosmic Velocity') plt.xlabel('Distance (Earth Radii)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities vs Distance from Earth') plt.grid(True) plt.legend() plt.show() 2.2 Key Observations Inverse Square Relationship : Both first and second cosmic velocities decrease with the square root of distance. Mass Dependence : Larger celestial bodies require higher velocities for escape. Radius Effect : For a given mass, smaller bodies have higher surface escape velocities. 3. Applications in Space Exploration 3.1 Launch Requirements Let's visualize the minimum energy requirements for different space missions: # Create mission energy requirements visualization missions = { 'Low Earth Orbit': 7.8, 'Geostationary Orbit': 11.2, 'Moon Transfer': 11.2, 'Mars Transfer': 11.6, 'Solar System Escape': 16.6 } plt.figure(figsize=(10, 6)) plt.barh(list(missions.keys()), list(missions.values())) plt.xlabel('Minimum Velocity Required (km/s)') plt.title('Velocity Requirements for Space Missions') plt.grid(True) plt.show() 3.2 Practical Considerations Atmospheric Drag : Requires additional energy to overcome Gravitational Assists : Can reduce required velocities Orbital Mechanics : Optimal launch windows and trajectories 4. Conclusion Understanding cosmic velocities is fundamental to space exploration. The relationships between these velocities help us: - Design efficient launch systems - Plan interplanetary missions - Calculate fuel requirements - Determine optimal trajectories The mathematical framework provided allows us to calculate precise requirements for any celestial body, making it an essential tool in modern space exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-basic-principles-of-gravitational-escape","text":"The concept of escape velocity emerges from the principle of energy conservation. For an object to escape a celestial body's gravitational field, its kinetic energy must equal or exceed the gravitational potential energy: \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{R} \\] Where: - \\(m\\) is the mass of the escaping object - \\(v\\) is the velocity - \\(G\\) is the gravitational constant - \\(M\\) is the mass of the celestial body - \\(R\\) is the radius from the center of the celestial body","title":"1.1 Basic Principles of Gravitational Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-the-three-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) For circular orbit: Gravitational force equals centripetal force $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) From energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}v_1 $$ Third Cosmic Velocity (Solar System Escape Velocity) Combines planetary escape velocity with solar escape velocity: $$ v_3 = \\sqrt{v_2^2 + v_{sun}^2} $$ where \\(v_{sun}\\) is the orbital velocity around the Sun. Let's visualize these relationships with Python: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Set style plt.style.use('default') # Using default style instead of seaborn colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'] # Custom color palette def calculate_velocities(mass, radius, distance_from_sun=None): \"\"\"Calculate cosmic velocities for a celestial body\"\"\" v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 if distance_from_sun: v_sun = np.sqrt(G * 1.989e30 / distance_from_sun) # Sun's mass v3 = np.sqrt(v2**2 + v_sun**2) return v1, v2, v3 return v1, v2 # Celestial body data (mass in kg, radius in m, distance from sun in m) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.496e11), \"Mars\": (6.417e23, 3.389e6, 2.279e11), \"Jupiter\": (1.898e27, 6.9911e7, 7.786e11), \"Moon\": (7.34767309e22, 1.737e6, None), \"Mercury\": (3.285e23, 2.439e6, 5.79e10) } # Calculate velocities velocities = {body: calculate_velocities(mass, radius, dist) for body, (mass, radius, dist) in bodies.items()} # Create visualization fig = plt.figure(figsize=(15, 10)) gs = plt.GridSpec(2, 2) # Plot 1: Bar comparison ax1 = fig.add_subplot(gs[0, :]) bodies_list = list(bodies.keys()) v1_vals = [v[0]/1000 for v in velocities.values()] # Convert to km/s v2_vals = [v[1]/1000 for v in velocities.values()] v3_vals = [v[2]/1000 if len(v) > 2 else 0 for v in velocities.values()] x = np.arange(len(bodies_list)) width = 0.25 bars1 = ax1.bar(x - width, v1_vals, width, label='First Cosmic Velocity', color=colors[0]) bars2 = ax1.bar(x, v2_vals, width, label='Second Cosmic Velocity', color=colors[1]) bars3 = ax1.bar(x + width, v3_vals, width, label='Third Cosmic Velocity', color=colors[2]) ax1.set_ylabel('Velocity (km/s)') ax1.set_title('Comparison of Cosmic Velocities for Different Celestial Bodies') ax1.set_xticks(x) ax1.set_xticklabels(bodies_list) ax1.legend() ax1.grid(True, alpha=0.3) # Plot 2: Velocity vs Radius relationship ax2 = fig.add_subplot(gs[1, 0]) radii = np.linspace(1e6, 1e8, 1000) masses = [1e24, 5e24, 1e25] for i, mass in enumerate(masses): v1 = np.sqrt(G * mass / radii) ax2.plot(radii/1000, v1/1000, label=f'Mass = {mass:.1e} kg', color=colors[i]) ax2.set_xlabel('Radius (km)') ax2.set_ylabel('First Cosmic Velocity (km/s)') ax2.set_title('First Cosmic Velocity vs Radius') ax2.legend() ax2.set_xscale('log') ax2.set_yscale('log') ax2.grid(True, alpha=0.3) # Plot 3: Escape velocity field ax3 = fig.add_subplot(gs[1, 1]) x = np.linspace(-2, 2, 100) y = np.linspace(-2, 2, 100) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) V = np.sqrt(2*G*5.972e24/(R*6.371e6))/1000 # Earth's escape velocity field contour = ax3.contour(X, Y, V, levels=15, colors='black') ax3.clabel(contour, inline=True, fontsize=8) ax3.set_title('Earth Escape Velocity Field (km/s)') ax3.set_xlabel('Distance (Earth Radii)') ax3.set_ylabel('Distance (Earth Radii)') ax3.grid(True, alpha=0.3) plt.tight_layout() plt.show()","title":"1.2 The Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-analysis-of-results","text":"","title":"2. Analysis of Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-velocity-relationships","text":"Let's examine how these velocities vary with distance from a celestial body: # Create distance-velocity relationship plot plt.figure(figsize=(10, 6)) distances = np.linspace(1, 10, 1000) # In Earth radii earth_mass = 5.972e24 earth_radius = 6.371e6 v1 = np.sqrt(G * earth_mass / (distances * earth_radius)) / 1000 v2 = np.sqrt(2) * v1 plt.plot(distances, v1, label='First Cosmic Velocity') plt.plot(distances, v2, label='Second Cosmic Velocity') plt.xlabel('Distance (Earth Radii)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities vs Distance from Earth') plt.grid(True) plt.legend() plt.show()","title":"2.1 Velocity Relationships"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-key-observations","text":"Inverse Square Relationship : Both first and second cosmic velocities decrease with the square root of distance. Mass Dependence : Larger celestial bodies require higher velocities for escape. Radius Effect : For a given mass, smaller bodies have higher surface escape velocities.","title":"2.2 Key Observations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-applications-in-space-exploration","text":"","title":"3. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-launch-requirements","text":"Let's visualize the minimum energy requirements for different space missions: # Create mission energy requirements visualization missions = { 'Low Earth Orbit': 7.8, 'Geostationary Orbit': 11.2, 'Moon Transfer': 11.2, 'Mars Transfer': 11.6, 'Solar System Escape': 16.6 } plt.figure(figsize=(10, 6)) plt.barh(list(missions.keys()), list(missions.values())) plt.xlabel('Minimum Velocity Required (km/s)') plt.title('Velocity Requirements for Space Missions') plt.grid(True) plt.show()","title":"3.1 Launch Requirements"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-practical-considerations","text":"Atmospheric Drag : Requires additional energy to overcome Gravitational Assists : Can reduce required velocities Orbital Mechanics : Optimal launch windows and trajectories","title":"3.2 Practical Considerations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-conclusion","text":"Understanding cosmic velocities is fundamental to space exploration. The relationships between these velocities help us: - Design efficient launch systems - Plan interplanetary missions - Calculate fuel requirements - Determine optimal trajectories The mathematical framework provided allows us to calculate precise requirements for any celestial body, making it an essential tool in modern space exploration.","title":"4. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Theoretical Foundation Types of Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory) : If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory) : If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory) : If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion. 2. Mathematical Analysis Equations of Motion The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations. 3. Computational Model The following Python script simulates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in km, velocity in km/s) x0, y0 = R + 500000, 0 # Initial altitude: 500 km vx0, vy0 = 7.8e3, 0 # Initial velocity (near orbital velocity) y_init = [x0, vx0, y0, vy0] # Time span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve ODE sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of a Freely Released Payload') plt.legend() plt.grid() plt.show() This script: - Defines gravitational equations of motion. - Uses numerical integration to compute the trajectory. - Plots the resulting trajectory. 4. Practical Applications Satellite Deployment : Ensuring correct initial conditions for stable orbits. Reentry Scenarios : Calculating reentry angles and speeds. Escape Missions : Planning interplanetary transfers. 5. Conclusion Understanding the possible trajectories of a released payload is crucial for space missions. By analyzing the velocity and gravitational influence, we can determine whether an object will reenter, orbit, or escape Earth.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity \\( v \\) relative to Earth's gravitational pull. The possible trajectories are: Suborbital (Parabolic Trajectory) : If the payload does not reach orbital velocity, it follows a ballistic path back to Earth. Orbital (Elliptical Trajectory) : If the velocity is between the first cosmic velocity \\( v_1 \\) (orbital velocity) and escape velocity \\( v_2 \\) , the payload enters an elliptical orbit. Escape (Hyperbolic Trajectory) : If the velocity exceeds escape velocity \\( v_2 \\) , the payload follows a hyperbolic trajectory and escapes Earth's gravity. These scenarios are governed by Newton's Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ and Kepler\u2019s Laws of Motion.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton\u2019s Second Law: $$ \\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3} \\mathbf{r} $$ where: - \\( \\mathbf{r} \\) is the position vector, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Numerical integration (e.g., Runge-Kutta method) is used to solve these equations.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computational-model","text":"The following Python script simulates and visualizes the trajectory of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Equations of motion def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position in km, velocity in km/s) x0, y0 = R + 500000, 0 # Initial altitude: 500 km vx0, vy0 = 7.8e3, 0 # Initial velocity (near orbital velocity) y_init = [x0, vx0, y0, vy0] # Time span t_span = (0, 10000) t_eval = np.linspace(0, 10000, 1000) # Solve ODE sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of a Freely Released Payload') plt.legend() plt.grid() plt.show() This script: - Defines gravitational equations of motion. - Uses numerical integration to compute the trajectory. - Plots the resulting trajectory.","title":"3. Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-practical-applications","text":"Satellite Deployment : Ensuring correct initial conditions for stable orbits. Reentry Scenarios : Calculating reentry angles and speeds. Escape Missions : Planning interplanetary transfers.","title":"4. Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"Understanding the possible trajectories of a released payload is crucial for space missions. By analyzing the velocity and gravitational influence, we can determine whether an object will reenter, orbit, or escape Earth.","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Theoretical Background Wave Interference Interference occurs when two or more waves overlap, leading to constructive (amplification) and destructive (cancellation) effects. On a water surface, waves emanating from multiple sources interact to form intricate interference patterns. The displacement \\( \\eta(x, y, t) \\) of a circular wave originating from a point source \\( (x_0, y_0) \\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: - \\( A \\) is the wave amplitude, - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the radial distance from the source, - \\( \\phi \\) is the initial phase. When multiple sources are present, the net displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of sources. 2. Problem Setup 1. Choosing a Regular Polygon We select a regular polygon (e.g., equilateral triangle, square, pentagon) and place wave sources at its vertices. 2. Computing the Superposition Each vertex of the polygon acts as a wave source, and their combined effect determines the final interference pattern. 3. Computational Model The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_ = 10 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (arbitrary unit) t = 0 # Time snapshot # Define polygon vertices (square as an example) N = 4 # Number of sources (square) radius = 20 # Distance from center angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Define grid for visualization x = np.linspace(-30, 30, 300) y = np.linspace(-30, 30, 300) X, Y = np.meshgrid(x, y) # Compute wave interference pattern eta_sum = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t) # Avoid division by zero # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.imshow(eta_sum, extent=[-30, 30, -30, 30], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Interference Pattern for a Square Wave Source') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show() 4. Observations and Analysis Constructive Interference : Bright regions indicate where wave crests reinforce each other. Destructive Interference : Dark regions indicate cancellation due to phase differences. Polygonal Symmetry : The interference pattern reflects the symmetry of the chosen polygon. 5. Conclusion This simulation demonstrates how waves from multiple sources interact to form interference patterns. By varying the polygon shape and wave parameters, we can analyze different wave behaviors useful in acoustics, optics, and fluid dynamics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a Water Surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference","text":"Interference occurs when two or more waves overlap, leading to constructive (amplification) and destructive (cancellation) effects. On a water surface, waves emanating from multiple sources interact to form intricate interference patterns. The displacement \\( \\eta(x, y, t) \\) of a circular wave originating from a point source \\( (x_0, y_0) \\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos\\left(kr - \\omega t + \\phi\\right) \\] where: - \\( A \\) is the wave amplitude, - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the radial distance from the source, - \\( \\phi \\) is the initial phase. When multiple sources are present, the net displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where \\( N \\) is the number of sources.","title":"Wave Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-problem-setup","text":"","title":"2. Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-choosing-a-regular-polygon","text":"We select a regular polygon (e.g., equilateral triangle, square, pentagon) and place wave sources at its vertices.","title":"1. Choosing a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-computing-the-superposition","text":"Each vertex of the polygon acts as a wave source, and their combined effect determines the final interference pattern.","title":"2. Computing the Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-computational-model","text":"The following Python script simulates and visualizes the interference pattern. import numpy as np import matplotlib.pyplot as plt # Define wave parameters A = 1 # Amplitude lambda_ = 10 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (arbitrary unit) t = 0 # Time snapshot # Define polygon vertices (square as an example) N = 4 # Number of sources (square) radius = 20 # Distance from center angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Define grid for visualization x = np.linspace(-30, 30, 300) y = np.linspace(-30, 30, 300) X, Y = np.meshgrid(x, y) # Compute wave interference pattern eta_sum = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A / np.sqrt(R + 1e-6) * np.cos(k * R - omega * t) # Avoid division by zero # Plot the interference pattern plt.figure(figsize=(8, 6)) plt.imshow(eta_sum, extent=[-30, 30, -30, 30], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Interference Pattern for a Square Wave Source') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show()","title":"3. Computational Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"Constructive Interference : Bright regions indicate where wave crests reinforce each other. Destructive Interference : Dark regions indicate cancellation due to phase differences. Polygonal Symmetry : The interference pattern reflects the symmetry of the chosen polygon.","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This simulation demonstrates how waves from multiple sources interact to form interference patterns. By varying the polygon shape and wave parameters, we can analyze different wave behaviors useful in acoustics, optics, and fluid dynamics.","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation import matplotlib.gridspec as gridspec def simulate_uniform_B(q, m, B, v0, r0, dt, steps): \"\"\"Enhanced simulation with energy and momentum tracking\"\"\" r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) E_kinetic = np.zeros(steps) angular_momentum = np.zeros((steps, 3)) magnetic_moment = np.zeros(steps) r[0] = r0 v[0] = v0 # Initial values E_kinetic[0] = 0.5 * m * np.sum(v[0]**2) angular_momentum[0] = m * np.cross(r[0], v[0]) B_mag = np.linalg.norm(B) v_perp = v[0] - np.dot(v[0], B) * B / B_mag**2 magnetic_moment[0] = 0.5 * m * np.sum(v_perp**2) / B_mag for i in range(1, steps): F = q * np.cross(v[i-1], B) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Calculate conserved quantities E_kinetic[i] = 0.5 * m * np.sum(v[i]**2) angular_momentum[i] = m * np.cross(r[i], v[i]) v_perp = v[i] - np.dot(v[i], B) * B / B_mag**2 magnetic_moment[i] = 0.5 * m * np.sum(v_perp**2) / B_mag return r, v, E_kinetic, angular_momentum, magnetic_moment def simulate_EB_fields(q, m, E, B, v0, r0, dt, steps): \"\"\"Enhanced E\u00d7B drift simulation with additional physics parameters\"\"\" r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) drift_velocity = np.zeros((steps, 3)) gyroradius = np.zeros(steps) total_energy = np.zeros(steps) r[0] = r0 v[0] = v0 B_mag = np.linalg.norm(B) drift_velocity_theoretical = np.cross(E, B) / (B_mag**2) for i in range(1, steps): F = q * (E + np.cross(v[i-1], B)) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Calculate drift velocity and gyroradius v_perp = v[i] - np.dot(v[i], B) * B / (B_mag**2) drift_velocity[i] = np.cross(E, B) / (B_mag**2) gyroradius[i] = m * np.linalg.norm(v_perp) / (abs(q) * B_mag) # Calculate total energy (kinetic + potential) total_energy[i] = 0.5 * m * np.sum(v[i]**2) + q * np.dot(E, r[i]) return r, v, drift_velocity, gyroradius, total_energy Parameters q = 1.6e-19 # electron charge m = 9.1e-31 # electron mass B = np.array([0, 0, 0.1]) # magnetic field in T E = np.array([1000, 0, 0]) # electric field in V/m v0 = np.array([1e6, 1e6, 0]) # initial velocity r0 = np.array([0, 0, 0]) # initial position dt = 1e-11 steps = 1000 Run simulations r_B, v_B, E_kin, L, mu = simulate_uniform_B(q, m, B, v0, r0, dt, steps) r_EB, v_EB, v_drift, rg, E_total = simulate_EB_fields(q, m, E, B, v0, r0, dt, steps) Create comprehensive visualization with 8 subplots plt.style.use('seaborn-darkgrid') fig = plt.figure(figsize=(20, 15)) gs = gridspec.GridSpec(4, 2) 1. 3D trajectory in B field ax1 = fig.add_subplot(gs[0, 0], projection='3d') ax1.plot(r_B[:, 0], r_B[:, 1], r_B[:, 2], 'b-', label='Trajectory') ax1.set_title('3D Particle Trajectory (B field)') ax1.set_xlabel('X (m)') ax1.set_ylabel('Y (m)') ax1.set_zlabel('Z (m)') ax1.legend() 2. Energy conservation in B field ax2 = fig.add_subplot(gs[0, 1]) t = np.arange(steps) * dt ax2.plot(t, E_kin / E_kin[0], 'g-', label='Normalized Kinetic Energy') ax2.set_title('Energy Conservation (B field)') ax2.set_xlabel('Time (s)') ax2.set_ylabel('E/E\u2080') ax2.legend() 3. E\u00d7B drift trajectory ax3 = fig.add_subplot(gs[1, 0], projection='3d') ax3.plot(r_EB[:, 0], r_EB[:, 1], r_EB[:, 2], 'r-', label='E\u00d7B Drift') ax3.set_title('3D Particle Trajectory (E\u00d7B fields)') ax3.set_xlabel('X (m)') ax3.set_ylabel('Y (m)') ax3.set_zlabel('Z (m)') ax3.legend() 4. Total energy in E\u00d7B fields ax4 = fig.add_subplot(gs[1, 1]) ax4.plot(t, E_total / E_total[0], 'm-', label='Normalized Total Energy') ax4.set_title('Total Energy Conservation (E\u00d7B fields)') ax4.set_xlabel('Time (s)') ax4.set_ylabel('E_total/E\u2080') ax4.legend() 5. Magnetic moment conservation ax5 = fig.add_subplot(gs[2, 0]) ax5.plot(t, mu / mu[0], 'c-', label='Normalized Magnetic Moment') ax5.set_title('Magnetic Moment Conservation') ax5.set_xlabel('Time (s)') ax5.set_ylabel('\u03bc/\u03bc\u2080') ax5.legend() 6. Angular momentum components ax6 = fig.add_subplot(gs[2, 1]) ax6.plot(t, L[:, 0], 'b-', label='Lx') ax6.plot(t, L[:, 1], 'r-', label='Ly') ax6.plot(t, L[:, 2], 'g-', label='Lz') ax6.set_title('Angular Momentum Components') ax6.set_xlabel('Time (s)') ax6.set_ylabel('Angular Momentum (kg\u22c5m\u00b2/s)') ax6.legend() 7. Phase space plot (x-vx) ax7 = fig.add_subplot(gs[3, 0]) ax7.plot(r_B[:, 0], v_B[:, 0], 'k.', markersize=1, label='Phase Space') ax7.set_title('Phase Space (x-vx)') ax7.set_xlabel('Position x (m)') ax7.set_ylabel('Velocity vx (m/s)') ax7.legend() 8. Gyroradius evolution ax8 = fig.add_subplot(gs[3, 1]) ax8.plot(t, rg * 1e6, 'y-', label='Gyroradius') ax8.set_title('Gyroradius Evolution') ax8.set_xlabel('Time (s)') ax8.set_ylabel('Radius (\u03bcm)') ax8.legend() plt.tight_layout() plt.show() Additional theoretical analysis and formulas: \"\"\" Key Physics Formulas and Concepts: Cyclotron Frequency: \u03c9_c = qB/m Larmor Radius: r_L = mv_\u22a5/(qB) E\u00d7B Drift Velocity: v_d = (E\u00d7B)/B\u00b2 Magnetic Moment (First Adiabatic Invariant): \u03bc = mv_\u22a5\u00b2/(2B) Drift Velocities: Gradient B drift: v_\u2207B = (mv_\u22a5\u00b2/2qB\u00b3)(B\u00d7\u2207B) Curvature drift: v_c = (mv_\u2225\u00b2/qB\u00b3)R_c\u00d7B Polarization drift: v_p = (m/qB\u00b2)dE_\u22a5/dt Energy Conservation: d/dt(\u00bdmv\u00b2) = qE\u00b7v Canonical Momentum: P = mv + qA (A is vector potential) Magnetic Mirror Force: F_\u2225 = -\u03bc\u2207_\u2225B Mirror Ratio and Loss Cone: R = B_max/B_min sin\u00b2(\u03b8) > 1/R (trapping condition) Relativistic Effects: Relativistic mass: m = \u03b3m\u2080 Lorentz factor: \u03b3 = 1/\u221a(1-v\u00b2/c\u00b2) Relativistic cyclotron frequency: \u03c9_c = qB/(\u03b3m\u2080) \"\"\"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"q = 1.6e-19 # electron charge m = 9.1e-31 # electron mass B = np.array([0, 0, 0.1]) # magnetic field in T E = np.array([1000, 0, 0]) # electric field in V/m v0 = np.array([1e6, 1e6, 0]) # initial velocity r0 = np.array([0, 0, 0]) # initial position dt = 1e-11 steps = 1000","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#run-simulations","text":"r_B, v_B, E_kin, L, mu = simulate_uniform_B(q, m, B, v0, r0, dt, steps) r_EB, v_EB, v_drift, rg, E_total = simulate_EB_fields(q, m, E, B, v0, r0, dt, steps)","title":"Run simulations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#create-comprehensive-visualization-with-8-subplots","text":"plt.style.use('seaborn-darkgrid') fig = plt.figure(figsize=(20, 15)) gs = gridspec.GridSpec(4, 2)","title":"Create comprehensive visualization with 8 subplots"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-3d-trajectory-in-b-field","text":"ax1 = fig.add_subplot(gs[0, 0], projection='3d') ax1.plot(r_B[:, 0], r_B[:, 1], r_B[:, 2], 'b-', label='Trajectory') ax1.set_title('3D Particle Trajectory (B field)') ax1.set_xlabel('X (m)') ax1.set_ylabel('Y (m)') ax1.set_zlabel('Z (m)') ax1.legend()","title":"1. 3D trajectory in B field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-energy-conservation-in-b-field","text":"ax2 = fig.add_subplot(gs[0, 1]) t = np.arange(steps) * dt ax2.plot(t, E_kin / E_kin[0], 'g-', label='Normalized Kinetic Energy') ax2.set_title('Energy Conservation (B field)') ax2.set_xlabel('Time (s)') ax2.set_ylabel('E/E\u2080') ax2.legend()","title":"2. Energy conservation in B field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-eb-drift-trajectory","text":"ax3 = fig.add_subplot(gs[1, 0], projection='3d') ax3.plot(r_EB[:, 0], r_EB[:, 1], r_EB[:, 2], 'r-', label='E\u00d7B Drift') ax3.set_title('3D Particle Trajectory (E\u00d7B fields)') ax3.set_xlabel('X (m)') ax3.set_ylabel('Y (m)') ax3.set_zlabel('Z (m)') ax3.legend()","title":"3. E\u00d7B drift trajectory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-total-energy-in-eb-fields","text":"ax4 = fig.add_subplot(gs[1, 1]) ax4.plot(t, E_total / E_total[0], 'm-', label='Normalized Total Energy') ax4.set_title('Total Energy Conservation (E\u00d7B fields)') ax4.set_xlabel('Time (s)') ax4.set_ylabel('E_total/E\u2080') ax4.legend()","title":"4. Total energy in E\u00d7B fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-magnetic-moment-conservation","text":"ax5 = fig.add_subplot(gs[2, 0]) ax5.plot(t, mu / mu[0], 'c-', label='Normalized Magnetic Moment') ax5.set_title('Magnetic Moment Conservation') ax5.set_xlabel('Time (s)') ax5.set_ylabel('\u03bc/\u03bc\u2080') ax5.legend()","title":"5. Magnetic moment conservation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-angular-momentum-components","text":"ax6 = fig.add_subplot(gs[2, 1]) ax6.plot(t, L[:, 0], 'b-', label='Lx') ax6.plot(t, L[:, 1], 'r-', label='Ly') ax6.plot(t, L[:, 2], 'g-', label='Lz') ax6.set_title('Angular Momentum Components') ax6.set_xlabel('Time (s)') ax6.set_ylabel('Angular Momentum (kg\u22c5m\u00b2/s)') ax6.legend()","title":"6. Angular momentum components"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-phase-space-plot-x-vx","text":"ax7 = fig.add_subplot(gs[3, 0]) ax7.plot(r_B[:, 0], v_B[:, 0], 'k.', markersize=1, label='Phase Space') ax7.set_title('Phase Space (x-vx)') ax7.set_xlabel('Position x (m)') ax7.set_ylabel('Velocity vx (m/s)') ax7.legend()","title":"7. Phase space plot (x-vx)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-gyroradius-evolution","text":"ax8 = fig.add_subplot(gs[3, 1]) ax8.plot(t, rg * 1e6, 'y-', label='Gyroradius') ax8.set_title('Gyroradius Evolution') ax8.set_xlabel('Time (s)') ax8.set_ylabel('Radius (\u03bcm)') ax8.legend() plt.tight_layout() plt.show()","title":"8. Gyroradius evolution"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#additional-theoretical-analysis-and-formulas","text":"\"\"\" Key Physics Formulas and Concepts: Cyclotron Frequency: \u03c9_c = qB/m Larmor Radius: r_L = mv_\u22a5/(qB) E\u00d7B Drift Velocity: v_d = (E\u00d7B)/B\u00b2 Magnetic Moment (First Adiabatic Invariant): \u03bc = mv_\u22a5\u00b2/(2B) Drift Velocities: Gradient B drift: v_\u2207B = (mv_\u22a5\u00b2/2qB\u00b3)(B\u00d7\u2207B) Curvature drift: v_c = (mv_\u2225\u00b2/qB\u00b3)R_c\u00d7B Polarization drift: v_p = (m/qB\u00b2)dE_\u22a5/dt Energy Conservation: d/dt(\u00bdmv\u00b2) = qE\u00b7v Canonical Momentum: P = mv + qA (A is vector potential) Magnetic Mirror Force: F_\u2225 = -\u03bc\u2207_\u2225B Mirror Ratio and Loss Cone: R = B_max/B_min sin\u00b2(\u03b8) > 1/R (trapping condition) Relativistic Effects: Relativistic mass: m = \u03b3m\u2080 Lorentz factor: \u03b3 = 1/\u221a(1-v\u00b2/c\u00b2) Relativistic cyclotron frequency: \u03c9_c = qB/(\u03b3m\u2080) \"\"\"","title":"Additional theoretical analysis and formulas:"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Theoretical Background Graph Theory in Circuit Analysis In electrical circuit analysis, we can represent circuits as graphs where: - Nodes (vertices) represent junctions - Edges represent resistors - Edge weights represent resistance values The equivalent resistance \\( R_{eq} \\) between two points in a circuit can be calculated using graph-theoretic methods. This approach is particularly powerful for complex circuits where traditional series-parallel reduction becomes cumbersome. Mathematical Foundation For a circuit with \\(n\\) nodes and \\(m\\) resistors, we can use: Kirchhoff's Current Law (KCL) : [ \\sum_{k=1}^{n} I_k = 0 ] Kirchhoff's Voltage Law (KVL) : [ \\sum_{k=1}^{m} V_k = 0 ] Ohm's Law for each resistor: [ V = IR ] The conductance matrix \\(G\\) of the circuit is given by: \\[ G_{ij} = \\begin{cases} \\sum_{k} \\frac{1}{R_k} & \\text{if } i = j \\\\ -\\frac{1}{R_{ij}} & \\text{if } i \\text{ and } j \\text{ are connected} \\\\ 0 & \\text{otherwise} \\end{cases} \\] 2. Algorithm Implementation Basic Implementation Here's a Python implementation using NetworkX to handle graph operations: ```python import networkx as nx import numpy as np import matplotlib.pyplot as plt class CircuitSolver: def init (self): self.G = nx.Graph() def add_resistor(self, node1, node2, resistance): \"\"\"Add a resistor between two nodes.\"\"\" self.G.add_edge(node1, node2, weight=resistance) def get_conductance_matrix(self): \"\"\"Generate the conductance matrix for the circuit.\"\"\" n = self.G.number_of_nodes() G_matrix = np.zeros((n, n)) for i in range(n): for j in range(n): if i == j: # Diagonal elements: sum of conductances for neighbor in self.G.neighbors(i): G_matrix[i,i] += 1/self.G[i][neighbor]['weight'] elif self.G.has_edge(i,j): # Off-diagonal elements: negative conductance G_matrix[i,j] = -1/self.G[i][j]['weight'] return G_matrix def calculate_equivalent_resistance(self, source, sink): \"\"\"Calculate equivalent resistance between two nodes.\"\"\" n = self.G.number_of_nodes() G_matrix = self.get_conductance_matrix() # Remove one row and column to make matrix non-singular G_reduced = np.delete(np.delete(G_matrix, sink, 0), sink, 1) # Create current vector (1A entering source, -1A leaving sink) i = np.zeros(n-1) if source < sink: i[source] = 1 else: i[source-1] = 1 # Solve for node voltages v = np.linalg.solve(G_reduced, i) # Calculate equivalent resistance (voltage difference / current) # Since we're using 1A current, the voltage difference is equal to the resistance if source < sink: return abs(v[source] - 0) # sink voltage is 0 by our reference else: return abs(v[source-1] - 0) def visualize_circuit(self, ax=None, title=\"Circuit Graph\"): \"\"\"Visualize the circuit graph. Args: ax (matplotlib.axes.Axes, optional): Axes to plot on. If None, creates new figure title (str): Title for the plot \"\"\" if ax is None: plt.figure(figsize=(10, 8)) ax = plt.gca() pos = nx.spring_layout(self.G) # Draw nodes nx.draw_networkx_nodes(self.G, pos, node_color='lightblue', node_size=500, ax=ax) # Draw edges with resistance labels nx.draw_networkx_edges(self.G, pos, ax=ax) edge_labels = nx.get_edge_attributes(self.G, 'weight') nx.draw_networkx_edge_labels(self.G, pos, edge_labels) # Draw node labels nx.draw_networkx_labels(self.G, pos) ax.set_title(title) ax.axis('off') def test_circuits(): # Import matplotlib if not already imported import matplotlib.pyplot as plt # Create figure with subplots fig, axes = plt.subplots(1, 3, figsize=(15, 5)) ax1, ax2, ax3 = axes # Unpack the axes array # Test Case 1: Simple Series Circuit print(\"Test Case 1: Simple Series Circuit\") cs1 = CircuitSolver() cs1.add_resistor(0, 1, 2) cs1.add_resistor(1, 2, 3) r1 = cs1.calculate_equivalent_resistance(0, 2) print(f\"Equivalent Resistance: {r1}\u03a9\") cs1.visualize_circuit(ax1, f\"Series Circuit\\nReq = {r1:.1f}\u03a9\") # Test Case 2: Simple Parallel Circuit print(\"\\nTest Case 2: Simple Parallel Circuit\") cs2 = CircuitSolver() cs2.add_resistor(0, 1, 4) cs2.add_resistor(0, 1, 4) r2 = cs2.calculate_equivalent_resistance(0, 1) print(f\"Equivalent Resistance: {r2}\u03a9\") cs2.visualize_circuit(ax2, f\"Parallel Circuit\\nReq = {r2:.1f}\u03a9\") # Test Case 3: Complex Bridge Circuit print(\"\\nTest Case 3: Wheatstone Bridge Circuit\") cs3 = CircuitSolver() cs3.add_resistor(0, 1, 2) cs3.add_resistor(1, 2, 2) cs3.add_resistor(2, 3, 2) cs3.add_resistor(0, 4, 2) cs3.add_resistor(4, 3, 2) cs3.add_resistor(1, 4, 3) r3 = cs3.calculate_equivalent_resistance(0, 3) print(f\"Equivalent Resistance: {r3}\u03a9\") cs3.visualize_circuit(ax3, f\"Wheatstone Bridge\\nReq = {r3:.1f}\u03a9\") # Adjust layout and display plt.tight_layout() plt.show() if name == \" main \": test_circuits() 3. Analysis of Results Test Case Results Series Circuit : Expected: \\(R_{eq} = R_1 + R_2 = 5\\Omega\\) Calculated: \\(5\\Omega\\) Parallel Circuit : Expected: \\(R_{eq} = \\frac{R_1R_2}{R_1 + R_2} = 2\\Omega\\) Calculated: \\(2\\Omega\\) Wheatstone Bridge : More complex calculation Demonstrates the power of graph-theoretic approach Algorithm Efficiency The algorithm's complexity is dominated by: 1. Matrix operations: \\(O(n^3)\\) for solving linear equations 2. Graph operations: \\(O(E)\\) for building conductance matrix Where: - \\(n\\) is the number of nodes - \\(E\\) is the number of edges (resistors) 4. Conclusion The graph-theoretic approach to calculating equivalent resistance offers several advantages: Systematic : Handles complex circuits methodically Generalizable : Works for any circuit topology Automatable : Easy to implement in software Scalable : Can handle large circuits efficiently This method bridges the gap between electrical circuit theory and graph theory, demonstrating the power of mathematical abstraction in solving physical problems. 5. Further Improvements Possible enhancements to the current implementation: Add support for voltage and current sources Implement parallel processing for large circuits Add error handling for singular matrices Optimize matrix operations for sparse circuits","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"Equivalent Resistance Using Graph Theory","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-theory-in-circuit-analysis","text":"In electrical circuit analysis, we can represent circuits as graphs where: - Nodes (vertices) represent junctions - Edges represent resistors - Edge weights represent resistance values The equivalent resistance \\( R_{eq} \\) between two points in a circuit can be calculated using graph-theoretic methods. This approach is particularly powerful for complex circuits where traditional series-parallel reduction becomes cumbersome.","title":"Graph Theory in Circuit Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-foundation","text":"For a circuit with \\(n\\) nodes and \\(m\\) resistors, we can use: Kirchhoff's Current Law (KCL) : [ \\sum_{k=1}^{n} I_k = 0 ] Kirchhoff's Voltage Law (KVL) : [ \\sum_{k=1}^{m} V_k = 0 ] Ohm's Law for each resistor: [ V = IR ] The conductance matrix \\(G\\) of the circuit is given by: \\[ G_{ij} = \\begin{cases} \\sum_{k} \\frac{1}{R_k} & \\text{if } i = j \\\\ -\\frac{1}{R_{ij}} & \\text{if } i \\text{ and } j \\text{ are connected} \\\\ 0 & \\text{otherwise} \\end{cases} \\]","title":"Mathematical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-algorithm-implementation","text":"","title":"2. Algorithm Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#basic-implementation","text":"Here's a Python implementation using NetworkX to handle graph operations: ```python import networkx as nx import numpy as np import matplotlib.pyplot as plt class CircuitSolver: def init (self): self.G = nx.Graph() def add_resistor(self, node1, node2, resistance): \"\"\"Add a resistor between two nodes.\"\"\" self.G.add_edge(node1, node2, weight=resistance) def get_conductance_matrix(self): \"\"\"Generate the conductance matrix for the circuit.\"\"\" n = self.G.number_of_nodes() G_matrix = np.zeros((n, n)) for i in range(n): for j in range(n): if i == j: # Diagonal elements: sum of conductances for neighbor in self.G.neighbors(i): G_matrix[i,i] += 1/self.G[i][neighbor]['weight'] elif self.G.has_edge(i,j): # Off-diagonal elements: negative conductance G_matrix[i,j] = -1/self.G[i][j]['weight'] return G_matrix def calculate_equivalent_resistance(self, source, sink): \"\"\"Calculate equivalent resistance between two nodes.\"\"\" n = self.G.number_of_nodes() G_matrix = self.get_conductance_matrix() # Remove one row and column to make matrix non-singular G_reduced = np.delete(np.delete(G_matrix, sink, 0), sink, 1) # Create current vector (1A entering source, -1A leaving sink) i = np.zeros(n-1) if source < sink: i[source] = 1 else: i[source-1] = 1 # Solve for node voltages v = np.linalg.solve(G_reduced, i) # Calculate equivalent resistance (voltage difference / current) # Since we're using 1A current, the voltage difference is equal to the resistance if source < sink: return abs(v[source] - 0) # sink voltage is 0 by our reference else: return abs(v[source-1] - 0) def visualize_circuit(self, ax=None, title=\"Circuit Graph\"): \"\"\"Visualize the circuit graph. Args: ax (matplotlib.axes.Axes, optional): Axes to plot on. If None, creates new figure title (str): Title for the plot \"\"\" if ax is None: plt.figure(figsize=(10, 8)) ax = plt.gca() pos = nx.spring_layout(self.G) # Draw nodes nx.draw_networkx_nodes(self.G, pos, node_color='lightblue', node_size=500, ax=ax) # Draw edges with resistance labels nx.draw_networkx_edges(self.G, pos, ax=ax) edge_labels = nx.get_edge_attributes(self.G, 'weight') nx.draw_networkx_edge_labels(self.G, pos, edge_labels) # Draw node labels nx.draw_networkx_labels(self.G, pos) ax.set_title(title) ax.axis('off') def test_circuits(): # Import matplotlib if not already imported import matplotlib.pyplot as plt # Create figure with subplots fig, axes = plt.subplots(1, 3, figsize=(15, 5)) ax1, ax2, ax3 = axes # Unpack the axes array # Test Case 1: Simple Series Circuit print(\"Test Case 1: Simple Series Circuit\") cs1 = CircuitSolver() cs1.add_resistor(0, 1, 2) cs1.add_resistor(1, 2, 3) r1 = cs1.calculate_equivalent_resistance(0, 2) print(f\"Equivalent Resistance: {r1}\u03a9\") cs1.visualize_circuit(ax1, f\"Series Circuit\\nReq = {r1:.1f}\u03a9\") # Test Case 2: Simple Parallel Circuit print(\"\\nTest Case 2: Simple Parallel Circuit\") cs2 = CircuitSolver() cs2.add_resistor(0, 1, 4) cs2.add_resistor(0, 1, 4) r2 = cs2.calculate_equivalent_resistance(0, 1) print(f\"Equivalent Resistance: {r2}\u03a9\") cs2.visualize_circuit(ax2, f\"Parallel Circuit\\nReq = {r2:.1f}\u03a9\") # Test Case 3: Complex Bridge Circuit print(\"\\nTest Case 3: Wheatstone Bridge Circuit\") cs3 = CircuitSolver() cs3.add_resistor(0, 1, 2) cs3.add_resistor(1, 2, 2) cs3.add_resistor(2, 3, 2) cs3.add_resistor(0, 4, 2) cs3.add_resistor(4, 3, 2) cs3.add_resistor(1, 4, 3) r3 = cs3.calculate_equivalent_resistance(0, 3) print(f\"Equivalent Resistance: {r3}\u03a9\") cs3.visualize_circuit(ax3, f\"Wheatstone Bridge\\nReq = {r3:.1f}\u03a9\") # Adjust layout and display plt.tight_layout() plt.show() if name == \" main \": test_circuits()","title":"Basic Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-analysis-of-results","text":"","title":"3. Analysis of Results"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-case-results","text":"Series Circuit : Expected: \\(R_{eq} = R_1 + R_2 = 5\\Omega\\) Calculated: \\(5\\Omega\\) Parallel Circuit : Expected: \\(R_{eq} = \\frac{R_1R_2}{R_1 + R_2} = 2\\Omega\\) Calculated: \\(2\\Omega\\) Wheatstone Bridge : More complex calculation Demonstrates the power of graph-theoretic approach","title":"Test Case Results"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-efficiency","text":"The algorithm's complexity is dominated by: 1. Matrix operations: \\(O(n^3)\\) for solving linear equations 2. Graph operations: \\(O(E)\\) for building conductance matrix Where: - \\(n\\) is the number of nodes - \\(E\\) is the number of edges (resistors)","title":"Algorithm Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-conclusion","text":"The graph-theoretic approach to calculating equivalent resistance offers several advantages: Systematic : Handles complex circuits methodically Generalizable : Works for any circuit topology Automatable : Easy to implement in software Scalable : Can handle large circuits efficiently This method bridges the gap between electrical circuit theory and graph theory, demonstrating the power of mathematical abstraction in solving physical problems.","title":"4. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-further-improvements","text":"Possible enhancements to the current implementation: Add support for voltage and current sources Implement parallel processing for large circuits Add error handling for singular matrices Optimize matrix operations for sparse circuits","title":"5. Further Improvements"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}